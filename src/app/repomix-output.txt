This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-19T10:28:47.464Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
ClientLayout.tsx
components/auth/AuthModal.tsx
components/auth/LoginForm.tsx
components/auth/LoginModal.tsx
components/auth/RegisterForm.tsx
components/favorites/FavoritesList.tsx
components/forms/formFields/InputField.tsx
components/forms/formFields/SelectField.tsx
components/forms/NewVenueForm.tsx
components/forms/ReportForm.tsx
components/layout/AppLayout.tsx
components/layout/BottomNavigation
components/map/BeerMap.tsx
components/map/components/LocationStatus.tsx
components/map/components/ReviewsModal.tsx
components/map/GoeLocationStatus.tsx
components/map/hooks/useMapInitialization.ts
components/map/hooks/useVenueMarkers.tsx
components/map/LocationAccuracyInfo.tsx
components/map/LocationInfo.tsx
components/map/MapComponent.tsx
components/map/popups/AddBeerModal.tsx
components/map/popups/ReviewModal.tsx
components/map/popups/VenuePopup.tsx
components/map/utils/api.ts
components/map/utils/helpers.ts
components/map/utils/mapCentering.ts
components/map/utils/markers.ts
components/reviews/ReviewForm.tsx
components/venues/VenueCard.tsx
components/venues/VenueList.tsx
components/venues/VenuePopupActions.tsx
globals.css
hooks/useAuth.ts
hooks/useGeolocation.ts
hooks/useNearbyVenues.ts
hooks/useVenues.ts
layout.tsx
page.tsx
services/api.ts
services/auth.ts
stores/useFavoritesStore.ts
types/index.ts
utils/constants.ts

================================================================
Repository Files
================================================================

================
File: ClientLayout.tsx
================
// src/app/ClientLayout.tsx
'use client';

import Script from "next/script";
import { Toaster } from 'react-hot-toast';
import { useAuth } from "./hooks/useAuth";
import { useEffect } from "react";
import { useFavoritesStore } from "./stores/useFavoritesStore";

export default function ClientLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const { isAuthenticated } = useAuth();
  
  useEffect(() => {
    if (isAuthenticated) {
      useFavoritesStore.getState().fetchFavorites();
    }
  }, [isAuthenticated]);

  return (
    <>
      {/* Leaflet core */}
      <Script
        src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossOrigin=""
        strategy="beforeInteractive"
      />
      
      {/* Plugins - load after Leaflet core */}
      <Script
        src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"
        strategy="afterInteractive"
      />
      <Script
        src="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol@0.79.0/dist/L.Control.Locate.min.js"
        strategy="afterInteractive"
      />

      <Toaster
        position="top-center"
        containerStyle={{
          top: 50
        }}
        toastOptions={{
          className: 'text-sm',
          duration: 3000,
          style: {
            maxWidth: '500px',
            padding: '12px 20px',
          },
          success: {
            style: {
              background: '#ECFDF5',
              color: '#065F46',
              border: '1px solid #6EE7B7',
            },
            icon: '✅',
          },
          error: {
            style: {
              background: '#FEF2F2',
              color: '#991B1B',
              border: '1px solid #FCA5A5',
            },
            icon: '⚠️',
            duration: 4000,
          },
        }}
      />

      <style jsx global>{`
        .custom-loading-toast {
          background: #FFF;
          color: #1F2937;
          border: 1px solid #E5E7EB;
        }

        .cluster-marker {
          width: 40px;
          height: 40px;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 50%;
          font-weight: bold;
          color: white;
          border: 2px solid white;
          box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .leaflet-container {
          font-family: inherit;
        }

        .leaflet-control-container .leaflet-bottom.leaflet-right {
          bottom: 35px !important; 
        }

        .leaflet-control-container .leaflet-right {
          right: 12px !important; 
        }

        .leaflet-popup-content-wrapper {
          padding: 0;
          overflow: hidden;
        }

        .leaflet-popup-content {
          margin: 0;
        }

        .venue-popup {
          min-width: 280px;
        }

        .locate-control {
          border: 2px solid rgba(0,0,0,0.2);
          border-radius: 4px;
        }

        .locate-control.active {
          color: #2563EB;
        }

        .leaflet-marker-icon {
          background: none;
          border: none;
        }

        /* MarkerCluster custom styles */
        .marker-cluster-small {
          background-color: rgba(181, 226, 140, 0.6);
        }
        .marker-cluster-small div {
          background-color: rgba(110, 204, 57, 0.6);
        }

        .marker-cluster-medium {
          background-color: rgba(241, 211, 87, 0.6);
        }
        .marker-cluster-medium div {
          background-color: rgba(240, 194, 12, 0.6);
        }

        .marker-cluster-large {
          background-color: rgba(253, 156, 115, 0.6);
        }
        .marker-cluster-large div {
          background-color: rgba(241, 128, 23, 0.6);
        }

        .marker-cluster {
          background-clip: padding-box;
          border-radius: 20px;
        }
        .marker-cluster div {
          width: 30px;
          height: 30px;
          margin-left: 5px;
          margin-top: 5px;
          text-align: center;
          border-radius: 15px;
          font: 12px "Helvetica Neue", Arial, Helvetica, sans-serif;
        }
        .marker-cluster span {
          line-height: 30px;
        }
      `}</style>

      {children}
    </>
  );
}

================
File: components/auth/AuthModal.tsx
================
// src/app/components/auth/AuthModal.tsx

import { Dialog } from '@headlessui/react';
import { X } from 'lucide-react';
import { useEffect, useState } from 'react';
import { LoginForm } from './LoginForm';
import { RegisterForm } from './RegisterForm';

interface AuthModalProps {
  isOpen: boolean;
  onClose: () => void;
  initialMode: 'login' | 'register';
}

export const AuthModal: React.FC<AuthModalProps> = ({ 
  isOpen, 
  onClose,
  initialMode
}) => {
  const [mode, setMode] = useState<'login' | 'register'>(initialMode);

  // Add this useEffect to update mode when initialMode changes
  useEffect(() => {
    setMode(initialMode);
  }, [initialMode]);

  return (
    <Dialog open={isOpen} onClose={onClose} className="relative z-50">
      <div className="fixed inset-0 bg-black/30" aria-hidden="true" />

      <div className="fixed inset-0 flex items-center justify-center p-4">
        <Dialog.Panel className="relative bg-white rounded-lg shadow-xl max-w-md w-full">
          <button
            onClick={onClose}
            className="absolute right-4 top-4 text-gray-400 hover:text-gray-500"
          >
            <X size={20} />
          </button>
          
          {mode === 'login' ? (
            <LoginForm 
              onClose={onClose} 
              onRegisterClick={() => setMode('register')}
            />
          ) : (
            <RegisterForm 
              onClose={onClose} 
              onLoginClick={() => setMode('login')}
            />
          )}
        </Dialog.Panel>
      </div>
    </Dialog>
  );
};

================
File: components/auth/LoginForm.tsx
================
import React, { useState } from 'react';
import { useAuth } from '../../hooks/useAuth';

interface LoginFormProps {
  onClose: () => void;
  onRegisterClick?: () => void;
}

export const LoginForm: React.FC<LoginFormProps> = ({ 
  onClose, 
  onRegisterClick = () => {} 
}) => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const { login } = useAuth();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setIsLoading(true);

    try {
      await login(email, password);
      onClose();
    } catch (err) {
      console.error(err);  // Log the actual error for debugging
      setError('Nieprawidłowy email lub hasło');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="bg-white p-6 rounded-lg shadow-lg w-full max-w-md mx-auto">
      <h2 className="text-2xl font-bold text-gray-900 mb-6">Zaloguj się</h2>
      
      {error && (
        <div className="bg-red-50 text-red-700 p-3 rounded-md mb-4">
          {error}
        </div>
      )}

      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label className="block text-sm font-medium text-gray-900 mb-1">
            Email
          </label>
          <input
            type="email"
            required
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-amber-500 focus:border-amber-500 text-gray-900"
            placeholder="Wprowadź adres email"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-900 mb-1">
            Hasło
          </label>
          <input
            type="password"
            required
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-amber-500 focus:border-amber-500 text-gray-900"
            placeholder="Wprowadź hasło"
          />
        </div>

        <button
          type="submit"
          disabled={isLoading}
          className="w-full py-2 px-4 bg-amber-600 text-white rounded-md hover:bg-amber-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-amber-500 disabled:opacity-50"
        >
          {isLoading ? 'Logowanie...' : 'Zaloguj się'}
        </button>

        {onRegisterClick && (
          <div className="text-center mt-4">
            <span className="text-sm text-gray-600">Nie masz jeszcze konta? </span>
            <button
              type="button"
              onClick={onRegisterClick}
              className="text-sm text-amber-600 hover:text-amber-700 font-medium"
            >
              Zarejestruj się
            </button>
          </div>
        )}
      </form>
    </div>
  );
};

================
File: components/auth/LoginModal.tsx
================
import { Dialog } from '@headlessui/react';
import { X } from 'lucide-react';
import { LoginForm } from './LoginForm';

interface LoginModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export const LoginModal: React.FC<LoginModalProps> = ({ isOpen, onClose }) => {
  const handleRegisterClick = () => {
    // TODO: Implement navigation to registration or open register modal
    console.log('Register clicked');
  };

  return (
    <Dialog open={isOpen} onClose={onClose} className="relative z-50">
      <div className="fixed inset-0 bg-black/30" aria-hidden="true" />

      <div className="fixed inset-0 flex items-center justify-center p-4">
        <Dialog.Panel className="relative bg-white rounded-lg shadow-xl max-w-md w-full">
          <button
            onClick={onClose}
            className="absolute right-4 top-4 text-gray-400 hover:text-gray-500"
          >
            <X size={20} />
          </button>
          
          <LoginForm 
            onClose={onClose} 
            onRegisterClick={handleRegisterClick} 
          />
        </Dialog.Panel>
      </div>
    </Dialog>
  );
};

================
File: components/auth/RegisterForm.tsx
================
import React, { useState } from 'react';
import { register } from '../../services/auth';

interface RegisterFormProps {
  onClose: () => void;
  onLoginClick: () => void;
}

export const RegisterForm: React.FC<RegisterFormProps> = ({ 
  onClose, 
  onLoginClick 
}) => {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    password: '',
    password_confirmation: ''
  });
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setIsLoading(true);

    try {
      await register(formData);
      window.location.reload();
      onClose();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Wystąpił błąd podczas rejestracji');
    } finally {
      setIsLoading(false);
    }
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setFormData(prev => ({
      ...prev,
      [e.target.name]: e.target.value
    }));
  };

  return (
    <div className="bg-white p-6 rounded-lg shadow-lg w-full max-w-md mx-auto">
      <h2 className="text-2xl font-bold text-gray-900 mb-6">Zarejestruj się</h2>
      
      {error && (
        <div className="bg-red-50 text-red-700 p-3 rounded-md mb-4">
          {error}
        </div>
      )}

      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label className="block text-sm font-medium text-gray-900 mb-1">
            Imię i nazwisko
          </label>
          <input
            type="text"
            name="name"
            required
            value={formData.name}
            onChange={handleChange}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-amber-500 focus:border-amber-500 text-gray-900"
            placeholder="Wprowadź imię i nazwisko"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-900 mb-1">
            Email
          </label>
          <input
            type="email"
            name="email"
            required
            value={formData.email}
            onChange={handleChange}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-amber-500 focus:border-amber-500 text-gray-900"
            placeholder="Wprowadź adres email"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-900 mb-1">
            Hasło
          </label>
          <input
            type="password"
            name="password"
            required
            value={formData.password}
            onChange={handleChange}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-amber-500 focus:border-amber-500 text-gray-900"
            placeholder="Wprowadź hasło"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-900 mb-1">
            Potwierdź hasło
          </label>
          <input
            type="password"
            name="password_confirmation"
            required
            value={formData.password_confirmation}
            onChange={handleChange}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-amber-500 focus:border-amber-500 text-gray-900"
            placeholder="Potwierdź hasło"
          />
        </div>

        <button
          type="submit"
          disabled={isLoading}
          className="w-full py-2 px-4 bg-amber-600 text-white rounded-md hover:bg-amber-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-amber-500 disabled:opacity-50"
        >
          {isLoading ? 'Rejestracja...' : 'Zarejestruj się'}
        </button>

        <div className="text-center mt-4">
          <span className="text-sm text-gray-600">Masz już konto? </span>
          <button
            type="button"
            onClick={onLoginClick}
            className="text-sm text-amber-600 hover:text-amber-700 font-medium"
          >
            Zaloguj się
          </button>
        </div>
      </form>
    </div>
  );
};

================
File: components/favorites/FavoritesList.tsx
================
import React, { useEffect } from 'react';
import { Star, Heart, MapPin, Beer, Loader2, Clock, Trash2 } from 'lucide-react';
import { useFavoritesStore } from '../../stores/useFavoritesStore';
import { useGeolocation } from '../../hooks/useGeolocation';

const calculateDistance = (lat1: number, lon1: number, lat2: number, lon2: number) => {
  const R = 6371; // Earth's radius in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c; // Distance in km
};

const formatDistance = (distance: number) => {
  if (distance < 1) {
    return `${(distance * 1000).toFixed(0)}m`;
  }
  return `${distance.toFixed(1)}km`;
};

const EmptyState = () => (
  <div className="p-8 flex flex-col items-center justify-center min-h-[400px] bg-white rounded-lg border border-gray-200">
    <Heart className="w-16 h-16 text-gray-300 mb-4" />
    <h3 className="text-xl font-bold text-gray-900 mb-2">
      Brak ulubionych miejsc
    </h3>
    <p className="text-gray-600 text-center max-w-sm">
      Dodaj miejsca do ulubionych klikając ikonę serca przy lokalach, aby mieć do nich szybki dostęp
    </p>
  </div>
);

const LoadingState = () => (
  <div className="p-8 flex justify-center items-center min-h-[400px]">
    <div className="flex flex-col items-center gap-4">
      <Loader2 className="h-12 w-12 animate-spin text-amber-500" />
      <p className="text-gray-600 font-medium">Ładowanie ulubionych...</p>
    </div>
  </div>
);

const ErrorState = ({ error }: { error: string }) => (
  <div className="p-8">
    <div className="bg-amber-50 text-amber-800 p-6 rounded-lg text-center">
      <h3 className="text-lg font-semibold mb-2">{error}</h3>
      <p>Zaloguj się, aby zobaczyć swoje ulubione miejsca</p>
    </div>
  </div>
);

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const FavoriteCard = ({ spot, userLocation, onRemove }: any) => {
  const cheapestBeer = spot.beers?.length > 0 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ? spot.beers.reduce((prev: any, current: any) => 
        (prev.price < current.price) ? prev : current
      )
    : null;

  const distance = userLocation 
    ? calculateDistance(
        userLocation.latitude, 
        userLocation.longitude, 
        spot.latitude, 
        spot.longitude
      )
    : null;

  const handleNavigate = () => {
    const url = `https://www.google.com/maps/dir/?api=1&destination=${spot.latitude},${spot.longitude}`;
    window.open(url, '_blank');
  };

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden transition-all hover:shadow-md">
      <div className="p-4 sm:p-6">
        <div className="flex flex-col sm:flex-row sm:items-start justify-between gap-4">
          <div className="flex-1 min-w-0">
            <h3 className="text-lg font-bold text-gray-900 mb-2 truncate">
              {spot.name}
            </h3>
            
            {cheapestBeer && (
              <div className="flex items-center text-gray-900 mb-3">
                <Beer className="w-4 h-4 mr-2 flex-shrink-0" />
                <span className="font-medium truncate">
                  {cheapestBeer.name}
                </span>
                <span className="mx-2">•</span>
                <span className="font-bold text-amber-600">
                  {cheapestBeer.price.toFixed(2)}
                </span>
              </div>
            )}

            {spot.address && (
              <div className="flex items-center text-gray-600 mb-3">
                <MapPin className="w-4 h-4 mr-2 flex-shrink-0" />
                <span className="truncate">{spot.address}</span>
              </div>
            )}

            <div className="flex flex-wrap items-center gap-2">
              <div className="flex items-center bg-amber-50 px-3 py-1 rounded-full">
                <Star className="w-4 h-4 text-amber-400 mr-1" />
                <span className="font-bold text-amber-700">
                  {spot.average_rating?.toFixed(1) || '0.0'}
                </span>
              </div>

              {distance && (
                <div className="flex items-center bg-blue-50 px-3 py-1 rounded-full">
                  <MapPin className="w-4 h-4 text-blue-500 mr-1" />
                  <span className="font-medium text-blue-700">
                    {formatDistance(distance)}
                  </span>
                </div>
              )}

              <div className="flex items-center text-gray-600">
                <Clock className="w-4 h-4 mr-1" />
                <span className="text-sm">Otwarte</span>
              </div>
            </div>
          </div>

          <div className="flex sm:flex-col gap-2 sm:items-end">
            <button
              onClick={() => onRemove(spot.id)}
              className="flex items-center gap-2 px-3 py-1.5 bg-red-50 text-red-600 rounded-full hover:bg-red-100 transition-colors"
            >
              <Trash2 className="w-4 h-4" />
              <span className="hidden sm:inline">Usuń</span>
            </button>
            
            <button
              onClick={handleNavigate}
              className="flex items-center gap-2 px-3 py-1.5 bg-amber-50 text-amber-600 rounded-full hover:bg-amber-100 transition-colors"
            >
              <MapPin className="w-4 h-4" />
              <span className="hidden sm:inline">Nawiguj</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

const FavoritesList = () => {
  const { 
    favorites, 
    isLoading, 
    error, 
    isInitialized,
    fetchFavorites,
    removeFavorite
  } = useFavoritesStore();

  const { latitude, longitude } = useGeolocation();

  useEffect(() => {
    if (!isInitialized) {
      fetchFavorites(true);
    }
  }, [isInitialized, fetchFavorites]);

  if (!isInitialized && isLoading) {
    return <LoadingState />;
  }

  if (error) {
    return <ErrorState error={error} />;
  }

  if (!isLoading && favorites.length === 0) {
    return <EmptyState />;
  }

  // Sort by distance if we have user location
  const sortedFavorites = [...favorites];
  if (latitude && longitude) {
    sortedFavorites.sort((a, b) => {
      const distA = calculateDistance(latitude, longitude, a.latitude, a.longitude);
      const distB = calculateDistance(latitude, longitude, b.latitude, b.longitude);
      return distA - distB;
    });
  }

  return (
    <div className="relative">
      {isLoading && isInitialized && (
        <div className="absolute inset-0 bg-white/50 flex items-center justify-center z-50">
          <Loader2 className="h-12 w-12 animate-spin text-amber-500" />
        </div>
      )}

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 p-4">
        {sortedFavorites.map((spot) => (
          <FavoriteCard 
            key={spot.id}
            spot={spot}
            userLocation={latitude && longitude ? { latitude, longitude } : null}
            onRemove={removeFavorite}
          />
        ))}
      </div>
    </div>
  );
};

export default FavoritesList;

================
File: components/forms/formFields/InputField.tsx
================
// src/app/components/forms/formFields/InputField.tsx
'use client';
import React from 'react';

interface InputFieldProps {
  label: string;
  type: 'text' | 'number';
  value: string | number | '';
  onChange: (value: string | number) => void;
  placeholder?: string;
  required?: boolean;
  icon?: string;
  step?: string;
}

export const InputField: React.FC<InputFieldProps> = ({
  label,
  type,
  value,
  onChange,
  placeholder,
  required = false,
  icon = '',
  step
}) => {
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = type === 'number' 
      ? e.target.value === '' ? 0 : Number(e.target.value)
      : e.target.value;
    onChange(newValue);
  };

  return (
    <div>
      <label className="block text-xl font-bold text-gray-900 mb-2">
        {icon} {label}
      </label>
      <input
        type={type}
        value={value}
        onChange={handleChange}
        className="w-full px-4 py-3 rounded-lg border-2 border-gray-300 focus:ring-2 focus:ring-amber-500 focus:border-amber-500 text-lg text-gray-900 bg-white placeholder-gray-500"
        placeholder={placeholder}
        required={required}
        step={step}
      />
    </div>
  );
};

================
File: components/forms/formFields/SelectField.tsx
================
// src/app/components/forms/formFields/SelectField.tsx
'use client';
import React from 'react';

interface Option {
  value: string;
  label: string;
}

interface SelectFieldProps {
  label: string;
  value: string;
  onChange: (value: string) => void;
  options: Option[];
  required?: boolean;
  icon?: string;
}

export const SelectField: React.FC<SelectFieldProps> = ({
  label,
  value,
  onChange,
  options,
  required = false,
  icon = ''
}) => {
  return (
    <div>
      <label className="block text-xl font-bold text-gray-900 mb-2">
        {icon} {label}
      </label>
      <select
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className="w-full px-4 py-3 rounded-lg border-2 border-gray-300 focus:ring-2 focus:ring-amber-500 focus:border-amber-500 text-lg text-gray-900 bg-white placeholder-gray-500"
        required={required}
      >
        {options.map(option => (
          <option key={option.value} value={option.value} className="text-gray-900">
            {option.label}
          </option>
        ))}
      </select>
    </div>
  );
};

================
File: components/forms/NewVenueForm.tsx
================
import React, { useState } from 'react';
import { X, Upload, Loader2 } from 'lucide-react';

interface FormData {
  name: string;
  address: string;
  streetNumber: string;
  city: string;
  beerName: string;
  beerPrice: string;
  image: File | null;
}

interface NewVenueFormProps {
  selectedLocation: { lat: number; lng: number };
  onSubmit: (data: FormData) => Promise<void>;
  onCancel: () => void;
}

const NewVenueForm: React.FC<NewVenueFormProps> = ({
  selectedLocation,
  onSubmit,
  onCancel
}) => {
  const [step, setStep] = useState(1);
  const [isLoadingAddress, setIsLoadingAddress] = useState(false);
  const [formData, setFormData] = useState<FormData>({
    name: '',
    address: '',
    streetNumber: '',
    city: '',
    beerName: '',
    beerPrice: '',
    image: null
  });
  const [previewImage, setPreviewImage] = useState<string | null>(null);

  // Fetch and format address when location is selected
  React.useEffect(() => {
    setIsLoadingAddress(true);
    fetch(`https://nominatim.openstreetmap.org/reverse?lat=${selectedLocation.lat}&lon=${selectedLocation.lng}&format=json`)
      .then(res => res.json())
      .then(data => {
        const address = data.address;
        const street = address.road || '';
        const number = address.house_number || '';
        const city = address.city || address.town || '';
        
        setFormData(prev => ({
          ...prev,
          address: `${street} ${number}, ${city}`,
          streetNumber: `${street} ${number}`,
          city: city
        }));
      })
      .catch(() => {
        setFormData(prev => ({
          ...prev,
          address: 'Nie udało się pobrać adresu'
        }));
      })
      .finally(() => setIsLoadingAddress(false));
  }, [selectedLocation]);

  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setFormData(prev => ({ ...prev, image: file }));
      const reader = new FileReader();
      reader.onloadend = () => {
        setPreviewImage(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    await onSubmit(formData);
  };

  const handleNext = () => {
    if (formData.name && formData.address) {
      setStep(2);
    }
  };

  return (
    <div className="max-w-3xl mx-auto bg-white rounded-t-xl shadow-lg">
      <div className="flex items-center justify-between p-6 border-b">
        <h2 className="text-2xl font-bold text-gray-900">
          {step === 1 ? 'Dodaj nowe miejsce' : 'Dodaj piwo'}
        </h2>
        <button
          onClick={onCancel}
          className="p-2 hover:bg-gray-100 rounded-full transition-colors"
        >
          <X className="w-6 h-6 text-gray-500" />
        </button>
      </div>

      <div className="p-6">
        {step === 1 ? (
          <div className="space-y-6">
            <div>
              <label className="block text-base font-medium text-gray-900 mb-2">
                Nazwa lokalu
              </label>
              <input
                type="text"
                value={formData.name}
                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                className="w-full px-4 py-3 text-lg rounded-lg border-2 border-gray-300 focus:ring-2 focus:ring-amber-500 focus:border-amber-500 bg-white shadow-sm text-gray-900 font-medium placeholder-gray-500"
                placeholder="np. Piwiarnia Pod Żółwiem"
                required
              />
            </div>

            <div>
              <label className="block text-base font-medium text-gray-900 mb-2">
                Adres
              </label>
              <div className="relative">
                <input
                  type="text"
                  value={formData.address}
                  readOnly
                  className="w-full px-4 py-3 text-lg bg-gray-50 border-2 border-gray-300 rounded-lg font-medium text-gray-900 shadow-sm"
                />
                {isLoadingAddress && (
                  <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
                    <Loader2 className="w-5 h-5 animate-spin text-gray-400" />
                  </div>
                )}
              </div>
            </div>

            <div className="pt-4">
              <button
                onClick={handleNext}
                disabled={!formData.name || !formData.address}
                className="w-full py-3 bg-amber-600 text-white rounded-lg hover:bg-amber-700 transition-colors font-medium disabled:opacity-50 disabled:cursor-not-allowed text-lg shadow-sm"
              >
                Dalej
              </button>
            </div>
          </div>
        ) : (
          <div className="space-y-6">
            <div>
              <label className="block text-base font-medium text-gray-900 mb-2">
                Nazwa piwa
              </label>
              <input
                type="text"
                value={formData.beerName}
                onChange={(e) => setFormData({ ...formData, beerName: e.target.value })}
                className="w-full px-4 py-3 text-lg rounded-lg border-2 border-gray-300 focus:ring-2 focus:ring-amber-500 focus:border-amber-500 bg-white shadow-sm text-gray-900 font-medium placeholder-gray-500"
                placeholder="np. Tyskie"
                required
              />
            </div>

            <div>
              <label className="block text-base font-medium text-gray-900 mb-2">
                Cena (zł)
              </label>
              <input
                type="number"
                value={formData.beerPrice}
                onChange={(e) => setFormData({ ...formData, beerPrice: e.target.value })}
                className="w-full px-4 py-3 text-lg rounded-lg border-2 border-gray-300 focus:ring-2 focus:ring-amber-500 focus:border-amber-500 bg-white shadow-sm text-gray-900 font-medium placeholder-gray-500"
                placeholder="0.00"
                step="0.01"
                required
              />
            </div>

            <div>
              <label className="block text-base font-medium text-gray-900 mb-2">
                Zdjęcie (opcjonalne)
              </label>
              {previewImage ? (
                <div className="relative rounded-lg overflow-hidden">
                  <img 
                    src={previewImage} 
                    alt="Preview" 
                    className="w-full h-48 object-cover"
                  />
                  <button
                    onClick={() => {
                      setPreviewImage(null);
                      setFormData(prev => ({ ...prev, image: null }));
                    }}
                    className="absolute top-2 right-2 p-1 bg-white rounded-full shadow-md hover:bg-gray-100"
                  >
                    <X size={16} />
                  </button>
                </div>
              ) : (
                <div className="border-2 border-dashed border-gray-300 rounded-lg p-4 hover:border-amber-500 transition-colors">
                  <label className="flex flex-col items-center gap-2 cursor-pointer">
                    <Upload className="w-6 h-6 text-gray-400" />
                    <span className="text-sm text-gray-600">Kliknij aby dodać zdjęcie</span>
                    <input
                      type="file"
                      className="hidden"
                      accept="image/*"
                      onChange={handleImageChange}
                    />
                  </label>
                </div>
              )}
            </div>

            <div className="flex gap-3 pt-4">
              <button
                onClick={() => setStep(1)}
                className="flex-1 py-3 bg-gray-100 text-gray-900 rounded-lg hover:bg-gray-200 transition-colors font-medium text-lg shadow-sm"
              >
                Wstecz
              </button>
              <button
                onClick={handleSubmit}
                disabled={!formData.beerName || !formData.beerPrice}
                className="flex-1 py-3 bg-amber-600 text-white rounded-lg hover:bg-amber-700 transition-colors font-medium disabled:opacity-50 disabled:cursor-not-allowed text-lg shadow-sm"
              >
                Dodaj miejsce
              </button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default NewVenueForm;

================
File: components/forms/ReportForm.tsx
================
import React, { useState } from 'react';
import { Flag, AlertCircle, X } from 'lucide-react';
import { Dialog } from '@headlessui/react';

const REPORT_REASONS = [
  { value: 'incorrect_price', label: 'Nieprawidłowa cena' },
  { value: 'incorrect_info', label: 'Błędne informacje' },
  { value: 'closed', label: 'Lokal zamknięty' },
  { value: 'inappropriate', label: 'Nieodpowiednia treść' },
  { value: 'spam', label: 'Spam' },
  { value: 'duplicate', label: 'Duplikat' },
  { value: 'other', label: 'Inny powód' }
];

interface ReportFormProps {
  isOpen: boolean;
  onClose: () => void;
  spotId: number;
  venueName: string;
}

const ReportForm: React.FC<ReportFormProps> = ({
  isOpen,
  onClose,
  spotId,
  venueName
}) => {
  const [reason, setReason] = useState('');
  const [description, setDescription] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showSuccess, setShowSuccess] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError(null);

    const token = localStorage.getItem('authToken');
    if (!token) {
      setError('Musisz być zalogowany, aby zgłosić problem');
      setIsSubmitting(false);
      return;
    }

    const reportData = {
      reason,
      description,
      spot_id: spotId
    };

    try {
      const response = await fetch('https://piwo.jacolos.pl/api/reports', {
        method: 'POST',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify(reportData)
      });

      const data = await response.json();

      if (!response.ok) {
        setError(data.message);
        return;
      }

      setShowSuccess(true);
      setReason('');
      setDescription('');

      setTimeout(() => {
        onClose();
        setShowSuccess(false);
      }, 2000);

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Wystąpił błąd podczas wysyłania zgłoszenia');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={isOpen} onClose={onClose} className="relative z-50">
      <div className="fixed inset-0 bg-black/30" aria-hidden="true" />
      
      <div className="fixed inset-0 flex items-start justify-center p-4 sm:items-center">
        <Dialog.Panel className="bg-white rounded-lg shadow-xl max-w-md w-full mt-16 sm:mt-0">
          {/* Header */}
          <div className="p-6 border-b">
            <div className="flex justify-between items-start">
              <div>
                <Dialog.Title className="text-xl font-bold text-gray-900">
                  Zgłoś problem
                </Dialog.Title>
                <p className="text-sm text-gray-600 mt-1">
                  {venueName}
                </p>
              </div>
              <button 
                onClick={onClose} 
                className="text-gray-500 hover:text-gray-700"
              >
                <X size={20} />
              </button>
            </div>
          </div>

          {/* Content */}
          <div className="p-6">
            {error && (
              <div className="bg-red-50 text-red-700 p-4 rounded-lg mb-4 flex items-center gap-2">
                <AlertCircle className="w-5 h-5" />
                <p>{error}</p>
              </div>
            )}

            {showSuccess && (
              <div className="bg-green-50 text-green-700 p-4 rounded-lg mb-4">
                Dziękujemy za zgłoszenie! Sprawdzimy je jak najszybciej.
              </div>
            )}

            <form onSubmit={handleSubmit} className="space-y-4">
              <div>
                <label className="block text-base font-medium text-gray-900 mb-1">
                  Powód zgłoszenia
                </label>
                <select
                  value={reason}
                  onChange={(e) => setReason(e.target.value)}
                  required
                  className="w-full px-4 py-3 rounded-lg border border-gray-300 text-gray-900 text-base focus:ring-2 focus:ring-red-500 focus:border-red-500"
                >
                  <option value="">Wybierz powód...</option>
                  {REPORT_REASONS.map((reason) => (
                    <option key={reason.value} value={reason.value}>
                      {reason.label}
                    </option>
                  ))}
                </select>
              </div>

              <div>
                <label className="block text-base font-medium text-gray-900 mb-1">
                  Opis problemu
                </label>
                <textarea
                  value={description}
                  onChange={(e) => setDescription(e.target.value)}
                  required
                  className="w-full px-4 py-3 rounded-lg border border-gray-300 text-gray-900 text-base focus:ring-2 focus:ring-red-500 focus:border-red-500 h-32 resize-none"
                  placeholder="Opisz dokładnie na czym polega problem..."
                />
              </div>

              <div className="flex justify-end gap-3 pt-2">
                <button
                  type="button"
                  onClick={onClose}
                  className="px-4 py-2 text-gray-900 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors text-base font-medium"
                >
                  Anuluj
                </button>
                <button
                  type="submit"
                  disabled={isSubmitting}
                  className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors text-base font-medium disabled:opacity-50 flex items-center gap-2"
                >
                  <Flag size={18} />
                  {isSubmitting ? 'Wysyłanie...' : 'Wyślij zgłoszenie'}
                </button>
              </div>
            </form>
          </div>
        </Dialog.Panel>
      </div>
    </Dialog>
  );
};

export default ReportForm;

================
File: components/layout/AppLayout.tsx
================
'use client';

import React, { useState } from 'react';
import { Map, ListOrdered, Heart, UserCircle, Search, LogOut, X } from 'lucide-react';
import { Dialog } from '@headlessui/react';
import { useAuth } from '../../hooks/useAuth';

interface TopNavigationProps {
  searchTerm: string;
  onSearchChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  activeTab: string;
  onTabChange: (tab: string) => void;
  onAuthModalOpen: (mode: 'login' | 'register') => void;
}

const TopNavigation: React.FC<TopNavigationProps> = ({ 
  searchTerm,
  onSearchChange,
  activeTab,
  onTabChange,
  onAuthModalOpen
}) => {
  const { isAuthenticated, user, logout } = useAuth();
  const [isProfileOpen, setProfileOpen] = useState(false);

  const handleLogout = () => {
    logout();
    setProfileOpen(false);
  };

  return (
    <div className="fixed top-0 left-0 right-0 bg-white border-b z-40">
      {/* Top Bar */}
      <div className="h-14 px-4 flex items-center justify-between gap-4">
        {/* Logo */}
        <div className="flex items-center gap-2">
          <span className="text-2xl">🍺</span>
          <h1 className="text-xl font-bold text-amber-600 hidden sm:block">BeerSpots</h1>
        </div>

        {/* Search Bar */}
        <div className="flex-1 max-w-xl">
          <div className="relative">
            <input
              type="text"
              value={searchTerm}
              onChange={onSearchChange}
              placeholder="Szukaj lokalu, piwa lub adresu..."
              className="w-full pl-10 pr-4 py-2 rounded-lg border-2 border-gray-200 focus:border-amber-500 focus:ring-2 focus:ring-amber-200"
            />
            <Search className="absolute left-3 top-2.5 w-5 h-5 text-gray-400" />
          </div>
        </div>

        {/* Desktop Navigation */}
        <div className="hidden md:flex items-center gap-4">
          <nav className="flex items-center gap-2">
            {navItems.map((item) => (
              <button
                key={item.id}
                onClick={() => onTabChange(item.id)}
                className={`px-3 py-1.5 rounded-lg flex items-center gap-2 transition-colors ${
                  activeTab === item.id
                    ? 'bg-amber-50 text-amber-600'
                    : 'text-gray-600 hover:bg-gray-50'
                }`}
              >
                {item.icon}
                <span className="font-medium">{item.label}</span>
              </button>
            ))}
          </nav>

          <div className="relative">
            <button
              onClick={() => setProfileOpen(!isProfileOpen)}
              className="p-2 rounded-lg hover:bg-gray-100"
            >
              <UserCircle className="w-6 h-6 text-gray-600" />
            </button>

            {/* Profile Dropdown */}
            {isProfileOpen && (
              <div className="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg border py-1">
                {isAuthenticated ? (
                  <>
                    <div className="px-4 py-2 text-sm border-b">
                      <div className="font-medium text-gray-900">
                        {user?.name}
                      </div>
                    </div>
                    <button
                      onClick={handleLogout}
                      className="w-full flex items-center px-4 py-2 text-sm text-red-600 hover:bg-red-50"
                    >
                      <LogOut size={16} className="mr-2" />
                      Wyloguj się
                    </button>
                  </>
                ) : (
                  <>
                    <button
                      onClick={() => onAuthModalOpen('login')}
                      className="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-50"
                    >
                      Zaloguj się
                    </button>
                    <button
                      onClick={() => onAuthModalOpen('register')}
                      className="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-50"
                    >
                      Zarejestruj się
                    </button>
                  </>
                )}
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

interface NavItem {
  id: string;
  label: string;
  icon: React.ReactNode;
}

const navItems: NavItem[] = [
  { id: 'map', label: 'Mapa', icon: <Map size={20} /> },
  { id: 'list', label: 'Lista', icon: <ListOrdered size={20} /> },
  { id: 'favorites', label: 'Ulubione', icon: <Heart size={20} /> }
];

interface AppLayoutProps {
  children: React.ReactNode;
}

export default function AppLayout({ children }: AppLayoutProps) {
  const [activeTab, setActiveTab] = useState('map');
  const [searchTerm, setSearchTerm] = useState('');
  const [isAuthModalOpen, setAuthModalOpen] = useState(false);
  const [authModalMode, setAuthModalMode] = useState<'login' | 'register'>('login');
//  const { isAuthenticated } = useAuth();

  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchTerm(e.target.value);
  };

  const handleTabChange = (tab: string) => {
    setActiveTab(tab);
  };

  const handleAuthModalOpen = (mode: 'login' | 'register') => {
    setAuthModalMode(mode);
    setAuthModalOpen(true);
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <TopNavigation
        searchTerm={searchTerm}
        onSearchChange={handleSearchChange}
        activeTab={activeTab}
        onTabChange={handleTabChange}
        onAuthModalOpen={handleAuthModalOpen}
      />

      <main className="pt-14 pb-16 md:pb-0">
        {children}
      </main>

      {/* Auth Modal */}
      <Dialog open={isAuthModalOpen} onClose={() => setAuthModalOpen(false)} className="relative z-50">
        <div className="fixed inset-0 bg-black/30" aria-hidden="true" />
        <div className="fixed inset-0 flex items-center justify-center p-4">
          <Dialog.Panel className="bg-white rounded-lg shadow-xl max-w-md w-full p-6">
            <div className="flex justify-between items-center mb-4">
              <Dialog.Title className="text-xl font-bold">
                {authModalMode === 'login' ? 'Zaloguj się' : 'Zarejestruj się'}
              </Dialog.Title>
              <button
                onClick={() => setAuthModalOpen(false)}
                className="text-gray-400 hover:text-gray-500"
              >
                <X size={20} />
              </button>
            </div>
          </Dialog.Panel>
        </div>
      </Dialog>
    </div>
  );
}

================
File: components/layout/BottomNavigation
================
import React from 'react';
import { Map, ListOrdered, Heart, Plus } from 'lucide-react';

const BottomNavigation = ({
  activeTab,
  onTabChange,
  isAuthenticated
}) => {
  const navItems = [
    { id: 'map', label: 'Mapa', icon: <Map size={20} /> },
    { id: 'list', label: 'Lista', icon: <ListOrdered size={20} /> },
    { id: 'add', label: 'Dodaj', icon: <Plus size={20} /> },
    ...(isAuthenticated ? [{ id: 'favorites', label: 'Ulubione', icon: <Heart size={20} /> }] : [])
  ];

  return (
    <div className="fixed bottom-0 left-0 right-0 bg-white border-t shadow-lg z-50">
      <div className="max-w-lg mx-auto px-4">
        <div className="flex justify-around items-center h-16">
          {navItems.map((item) => (
            <button
              key={item.id}
              onClick={() => onTabChange(item.id)}
              className={`flex flex-col items-center justify-center px-3 py-2 rounded-lg transition-colors ${
                activeTab === item.id
                  ? 'text-amber-600'
                  : 'text-gray-600 hover:text-amber-600'
              }`}
            >
              {item.icon}
              <span className="text-xs mt-1">{item.label}</span>
            </button>
          ))}
        </div>
      </div>
    </div>
  );
};

export default BottomNavigation;

================
File: components/map/BeerMap.tsx
================
'use client';

import dynamic from 'next/dynamic';
import type { LeafletMouseEvent } from 'leaflet';
import { Venue } from '../../types';
import { useEffect } from 'react';
import type { Map as LeafletMap } from 'leaflet';

const MapComponent = dynamic(() => import('./MapComponent'), {
 ssr: false,
 loading: () => (
   <div className="h-[400px] rounded-xl shadow-inner mb-4 flex items-center justify-center bg-gray-100">
     <p className="text-gray-500">Ładowanie mapy...</p>
   </div>
 )
});

interface BeerMapProps {
 venues: Venue[];
 onMapClick: (e: LeafletMouseEvent) => void;
 isAddMode: boolean;
 selectedLocation: {lat: number; lng: number} | null;
 onBoundsChanged: (center: {
   latitude: number;
   longitude: number;
   zoom: number;
 }) => void;
 onMapReady?: (map: LeafletMap) => void;
}

export const BeerMap: React.FC<BeerMapProps> = ({
 venues,
 onMapClick,
 isAddMode,
 selectedLocation,
 onBoundsChanged,
 onMapReady
}) => {
 const handleMapClick = (e: LeafletMouseEvent) => {
   if (!isAddMode) return;
   
   if (onMapClick) {
     onMapClick(e);
   }
 };

 useEffect(() => {
   // Upewnij się, że wszystko jest czyszczone przy wyjściu z trybu dodawania
   if (!isAddMode && selectedLocation) {
     onMapClick({ latlng: { lat: 0, lng: 0 } } as LeafletMouseEvent);
   }
 }, [isAddMode, onMapClick, selectedLocation]);

 return (
   <MapComponent 
     venues={venues}
     onMapClick={handleMapClick}
     isAddMode={isAddMode}
     selectedLocation={isAddMode ? selectedLocation : null}
     onBoundsChanged={onBoundsChanged}
     onMapReady={onMapReady}
 //    onLocationChange={handleLocationChange}
   />
 );
};

================
File: components/map/components/LocationStatus.tsx
================
// src/app/components/map/components/LocationStatus.tsx
interface LocationStatusProps {
    isLoading: boolean;
    error: string | null;
  }
  
  export const LocationStatus: React.FC<LocationStatusProps> = ({ isLoading, error }) => {
    if (isLoading) {
      return (
        <div className="absolute top-4 right-4 bg-white px-4 py-2 rounded-lg shadow-md z-[400]">
          <div className="flex items-center space-x-2">
            <div className="animate-spin rounded-full h-4 w-4 border-2 border-amber-500 border-t-transparent"></div>
            <span>Ustalanie twojej lokalizacji...</span>
          </div>
        </div>
      );
    }
  
    if (error) {
      return (
        <div className="absolute top-4 right-4 bg-white px-4 py-3 rounded-lg shadow-md z-[400] max-w-md">
          <div className="flex flex-col space-y-2">
            <div className="flex items-center space-x-2 text-amber-600">
              <svg className="w-5 h-5" fill="none" strokeWidth="1.5" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" d="M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z" />
              </svg>
              <span className="font-medium">Informacja o lokalizacji</span>
            </div>
            <p className="text-sm text-gray-600">{error}</p>
          </div>
        </div>
      );
    }
  
    return null;
  };

================
File: components/map/components/ReviewsModal.tsx
================
// src/app/components/reviews/ReviewsModal.tsx
import { Dialog } from '@headlessui/react';
import { X, Star } from 'lucide-react';
import { useState, useEffect } from 'react';

interface Review {
  id: number;
  rating: number;
  comment: string;
  visit_date: string;
  user: {
    name: string;
  };
}

interface ReviewsModalProps {
  isOpen: boolean;
  onClose: () => void;
  spotId: number;
  spotName: string;
}

export const ReviewsModal: React.FC<ReviewsModalProps> = ({
  isOpen,
  onClose,
  spotId,
  spotName
}) => {
  const [reviews, setReviews] = useState<Review[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchReviews = async () => {
      if (!isOpen) return;
      
      setIsLoading(true);
      setError(null);
      
      try {
        const response = await fetch(`https://piwo.jacolos.pl/api/beer-spots/${spotId}/spot-reviews`);
        if (!response.ok) throw new Error('Nie udało się pobrać opinii');
        
        const data = await response.json();
        setReviews(data.data || []);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Wystąpił błąd podczas pobierania opinii');
      } finally {
        setIsLoading(false);
      }
    };

    fetchReviews();
  }, [spotId, isOpen]);

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('pl-PL', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  };

  return (
    <Dialog open={isOpen} onClose={onClose} className="relative z-50">
      <div className="fixed inset-0 bg-black/30" aria-hidden="true" />

      <div className="fixed inset-0 flex items-center justify-center p-4">
        <Dialog.Panel className="bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[80vh] flex flex-col">
          <div className="p-6 border-b">
            <div className="flex justify-between items-start">
              <div>
                <Dialog.Title className="text-2xl font-bold text-gray-900">
                  Opinie o {spotName}
                </Dialog.Title>
                <p className="text-gray-600 mt-1">
                  {reviews.length} {reviews.length === 1 ? 'opinia' : 'opinii'}
                </p>
              </div>
              <button
                onClick={onClose}
                className="text-gray-400 hover:text-gray-500"
              >
                <X size={24} />
              </button>
            </div>
          </div>

          <div className="flex-1 overflow-y-auto p-6">
            {isLoading ? (
              <div className="flex justify-center items-center h-32">
                <div className="animate-spin rounded-full h-8 w-8 border-2 border-amber-500 border-t-transparent"></div>
              </div>
            ) : error ? (
              <div className="text-center text-red-600 p-4">
                {error}
              </div>
            ) : reviews.length === 0 ? (
              <div className="text-center text-gray-500 p-4">
                Brak opinii dla tego miejsca
              </div>
            ) : (
              <div className="space-y-6">
                {reviews.map((review) => (
                  <div key={review.id} className="border-b border-gray-100 pb-6 last:border-0">
                    <div className="flex justify-between items-start mb-2">
                      <div className="flex items-center">
                        <div className="bg-amber-50 px-3 py-1 rounded-full flex items-center">
                          <Star className="w-4 h-4 text-amber-400 mr-1" />
                          <span className="font-bold text-amber-700">{review.rating.toFixed(1)}</span>
                        </div>
                      </div>
                      <span className="text-sm text-gray-500">
                        {formatDate(review.visit_date)}
                      </span>
                    </div>
                    <p className="text-gray-700 mb-2">{review.comment}</p>
                    <p className="text-sm text-gray-500">
                      {review.user.name}
                    </p>
                  </div>
                ))}
              </div>
            )}
          </div>
        </Dialog.Panel>
      </div>
    </Dialog>
  );
};

================
File: components/map/GoeLocationStatus.tsx
================
// src/app/components/map/GeolocationStatus.tsx
import React from 'react';

interface GeolocationStatusProps {
  error: string | null;
  isLoading: boolean;
  source: 'gps' | 'ip' | 'default';
}

export const GeolocationStatus: React.FC<GeolocationStatusProps> = ({
  error,
  isLoading,
  source
}) => {
  const getStatusColor = () => {
    switch (source) {
      case 'gps':
        return 'bg-green-50 text-green-700';
      case 'ip':
        return 'bg-yellow-50 text-yellow-700';
      default:
        return 'bg-red-50 text-red-700';
    }
  };

  const getStatusMessage = () => {
    if (isLoading) return 'Ustalanie lokalizacji...';
    if (error) return error;
    switch (source) {
      case 'gps':
        return 'Lokalizacja GPS';
      case 'ip':
        return 'Lokalizacja na podstawie IP';
      default:
        return 'Domyślna lokalizacja';
    }
  };

  const getIcon = () => {
    if (isLoading) {
      return <div className="animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent" />;
    }
    switch (source) {
      case 'gps':
        return '📍';
      case 'ip':
        return '🌐';
      default:
        return '⚠️';
    }
  };

  return (
    <div className={`absolute bottom-4 left-4 px-4 py-3 rounded-lg shadow-md z-[400] ${getStatusColor()}`}>
      <div className="flex items-center space-x-2">
        <span>{getIcon()}</span>
        <span className="font-medium">{getStatusMessage()}</span>
      </div>
      {error && (
        <div className="mt-2 text-sm whitespace-pre-line">
          {error}
        </div>
      )}
    </div>
  );
};

================
File: components/map/hooks/useMapInitialization.ts
================
import { useEffect, useRef, useState, useCallback } from 'react';
import type { Map as LeafletMap, LeafletMouseEvent } from 'leaflet';
import { createUserLocationMarker, createPriceMarker } from '../utils/markers';
import { debounce } from 'lodash';

interface UseMapInitializationProps {
  mapRef: React.RefObject<HTMLDivElement>;
  latitude: number;
  longitude: number;
  isDefault: boolean;
  onBoundsChanged?: (center: { 
    latitude: number; 
    longitude: number; 
    zoom: number 
  }) => void;
  isAddMode?: boolean;
  onMapClick?: (e: LeafletMouseEvent) => void;
  selectedLocation?: { lat: number; lng: number } | null;
}

export const useMapInitialization = ({
  mapRef,
  latitude,
  longitude,
  isDefault,
  onBoundsChanged,
  isAddMode,
  onMapClick,
//  selectedLocation
}: UseMapInitializationProps) => {
  const mapInstance = useRef<LeafletMap | null>(null);
  const userLocationMarkerRef = useRef<L.Marker | null>(null);
  const tempMarkerRef = useRef<L.Marker | null>(null); 
 // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const locateControlRef = useRef<any>(null);
  const [mapReady, setMapReady] = useState(false);
  const isFirstLocationUpdateRef = useRef(true);
  const lastKnownPositionRef = useRef({ lat: latitude, lng: longitude });

  const debouncedHandleMapMove = useCallback(
    debounce(() => {
      if (!mapInstance.current || !onBoundsChanged) return;
      const center = mapInstance.current.getCenter();
      const zoom = mapInstance.current.getZoom();
      
      onBoundsChanged({
        latitude: center.lat,
        longitude: center.lng,
        zoom: zoom
      });
    }, 300),
    [onBoundsChanged]
  );

  // Bezpieczna aktualizacja pozycji markera bez zmiany widoku mapy
  const updateUserLocationMarker = useCallback((lat: number, lng: number) => {
    if (!mapInstance.current || !userLocationMarkerRef.current) return;

    // Aktualizuj tylko jeśli pozycja się znacząco zmieniła (np. o więcej niż 10 metrów)
    const distance = mapInstance.current.distance(
      [lastKnownPositionRef.current.lat, lastKnownPositionRef.current.lng],
      [lat, lng]
    );

    if (distance > 10) {
      try {
        userLocationMarkerRef.current.setLatLng([lat, lng]);
        lastKnownPositionRef.current = { lat, lng };
        
        // Aktualizuj popup jeśli jest otwarty
        const popup = userLocationMarkerRef.current.getPopup();
        if (popup && popup.isOpen()) {
          popup.setContent('Twoja aktualna lokalizacja');
        }
      } catch (error) {
        console.error('Error updating user location marker:', error);
      }
    }
  }, []);

  // Inicjalizacja mapy
  useEffect(() => {
    if (!mapRef.current || mapInstance.current) return;

    const initMap = async () => {
      if (typeof window === 'undefined' || !window.L) return;

      const mapElement = mapRef.current;
      if (!mapElement) return;

      try {
        const L = window.L;
        mapInstance.current = L.map(mapElement, {
          zoomControl: true,
          dragging: true,
          maxZoom: 19
        }).setView([latitude, longitude], 14);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '© OpenStreetMap contributors',
          maxZoom: 19
        }).addTo(mapInstance.current);

        mapInstance.current.on('moveend', debouncedHandleMapMove);
        mapInstance.current.on('zoomend', debouncedHandleMapMove);

        if (!isDefault) {
          const userMarker = L.marker([latitude, longitude], {
            icon: createUserLocationMarker()
          })
            .bindPopup('Twoja lokalizacja')
            .addTo(mapInstance.current);
          
          userLocationMarkerRef.current = userMarker;
        }

        try {
          // @ts-expect-error - Leaflet.Locate plugin
          locateControlRef.current = new L.Control.Locate({
            position: 'bottomright',
            strings: {
              title: 'Pokaż moją lokalizację'
            },
            // Wyłączamy automatyczne centrowanie i zoom
            keepCurrentZoomLevel: true,
            showPopup: false,
            showCompass: true,
            locateOptions: {
              enableHighAccuracy: true,
              maxZoom: 19
            },
            // Dostosowujemy zachowanie podczas lokalizacji
            onLocationError: (err: Error) => {
              console.warn('Location error:', err);
              // Możemy tutaj dodać własną obsługę błędów
            },
            onLocationOutsideMapBounds: () => {
              // Obsługa sytuacji gdy lokalizacja jest poza mapą
              console.warn('Location outside map bounds');
            }
          }).addTo(mapInstance.current);

          // Nasłuchuj zdarzeń lokalizacji
          mapInstance.current.on('locationfound', (e: { latlng: L.LatLng }) => {
            updateUserLocationMarker(e.latlng.lat, e.latlng.lng);

            // Przesuń mapę tylko przy pierwszej lokalizacji lub na wyraźne żądanie użytkownika
            if (isFirstLocationUpdateRef.current) {
              mapInstance.current?.setView(e.latlng, mapInstance.current.getZoom());
              isFirstLocationUpdateRef.current = false;
            }

            // Zapisz lokalizację w localStorage
            localStorage.setItem('lastKnownLocation', JSON.stringify({
              latitude: e.latlng.lat,
              longitude: e.latlng.lng,
              source: 'gps'
            }));
          });

        } catch (e) {
          console.warn('Locate control initialization error:', e);
        }

        setMapReady(true);
        debouncedHandleMapMove();
      } catch (error) {
        console.error('Map initialization error:', error);
      }
    };

    initMap();

    return () => {
      if (mapInstance.current) {
        mapInstance.current.off('moveend', debouncedHandleMapMove);
        mapInstance.current.off('zoomend', debouncedHandleMapMove);
        mapInstance.current.remove();
        mapInstance.current = null;
      }
      if (locateControlRef.current) {
        locateControlRef.current.stop();
      }
    };
  }, [latitude, longitude, isDefault, debouncedHandleMapMove, updateUserLocationMarker]);

  // Obsługa kliknięć na mapie
  useEffect(() => {
    if (!mapInstance.current || !mapReady) return;

    const handleMapClick = (e: LeafletMouseEvent) => {
      if (!isAddMode || !onMapClick) {
        if (tempMarkerRef.current) {
          tempMarkerRef.current.remove();
          tempMarkerRef.current = null;
        }
        return;
      }

      try {
        if (tempMarkerRef.current) {
          tempMarkerRef.current.remove();
          tempMarkerRef.current = null;
        }

        const L = window.L;
        tempMarkerRef.current = L.marker(e.latlng, {
          icon: createPriceMarker('Nowa', true)
        })
          .bindPopup('Nowa lokalizacja')
          .addTo(mapInstance.current!)
          .openPopup();

        onMapClick(e);
      } catch (error) {
        console.error('Error handling map click:', error);
      }
    };

    mapInstance.current.on('click', handleMapClick);

    return () => {
      if (mapInstance.current) {
        mapInstance.current.off('click', handleMapClick);
      }
      if (tempMarkerRef.current) {
        tempMarkerRef.current.remove();
        tempMarkerRef.current = null;
      }
    };
  }, [isAddMode, onMapClick, mapReady]);

  // Aktualizacja pozycji użytkownika bez zmiany widoku mapy
  useEffect(() => {
    if (!mapInstance.current || !mapReady || isDefault) return;
    updateUserLocationMarker(latitude, longitude);
  }, [latitude, longitude, mapReady, isDefault, updateUserLocationMarker]);

  return {
    mapInstance,
    mapReady,
    userLocationMarkerRef,
    tempMarkerRef
  };
};

================
File: components/map/hooks/useVenueMarkers.tsx
================
import React from 'react';
import { useEffect, useRef } from 'react';
import type { Map as LeafletMap, Marker } from 'leaflet';
import { createRoot } from 'react-dom/client';
import { createPriceMarker } from '../utils/markers';
import type { Venue } from '../../../types';
import VenuePopup from '../popups/VenuePopup';
import L from 'leaflet';

interface UseVenueMarkersProps {
 mapInstance: React.RefObject<LeafletMap | null>;
 mapReady: boolean;
 venues: Venue[];
 handleReviewsClick: (venue: Venue) => void;
 isAddMode?: boolean;
 selectedLocation?: {lat: number; lng: number} | null;
}

export const useVenueMarkers = ({
 mapInstance,
 mapReady,
 venues,
 handleReviewsClick,
 isAddMode = false,
 selectedLocation
}: UseVenueMarkersProps) => {
 const markersRef = useRef<Marker[]>([]);
 const markerClusterGroupRef = useRef<L.MarkerClusterGroup | null>(null);
 const popupContainerRef = useRef<HTMLDivElement | null>(null);
 const popupRootRef = useRef<ReturnType<typeof createRoot> | null>(null);
 const activeVenueRef = useRef<{id: number; lat: number; lng: number} | null>(null);
 const isUnmountedRef = useRef(false);
 const tempMarkerRef = useRef<Marker | null>(null);

 // Inicjalizacja kontenera dla popupu
 useEffect(() => {
   const container = document.createElement('div');
   container.className = 'leaflet-popup-fixed';
   container.style.position = 'absolute';
   container.style.zIndex = '10';
   container.style.display = 'none';
   container.style.transform = 'translate(-50%, -100%)';
   document.body.appendChild(container);
   popupContainerRef.current = container;
   popupRootRef.current = createRoot(container);
   isUnmountedRef.current = false;

   return () => {
     isUnmountedRef.current = true;
     if (popupRootRef.current) {
       popupRootRef.current.unmount();
       popupRootRef.current = null;
     }
     if (popupContainerRef.current) {
       popupContainerRef.current.remove();
       popupContainerRef.current = null;
     }
     if (tempMarkerRef.current) {
       tempMarkerRef.current.remove();
       tempMarkerRef.current = null;
     }
   };
 }, []);

 // Zarządzanie markerami i clusterami
 useEffect(() => {
   if (!mapInstance.current || !mapReady || !popupRootRef.current || !popupContainerRef.current) return;
   
   const map = mapInstance.current;

   // Inicjalizacja cluster group jeśli nie istnieje
   if (!markerClusterGroupRef.current) {
     const L = window.L;
     markerClusterGroupRef.current = L.markerClusterGroup({
       maxClusterRadius: 50,
       spiderfyOnMaxZoom: true,
       showCoverageOnHover: true,
       zoomToBoundsOnClick: true,
       disableClusteringAtZoom: 16,
       chunkedLoading: true
     });
     map.addLayer(markerClusterGroupRef.current);
   }

   const updatePopupPosition = () => {
     if (activeVenueRef.current && popupContainerRef.current && map) {
       const point = map.latLngToContainerPoint([
         activeVenueRef.current.lat,
         activeVenueRef.current.lng
       ]);
       
       const mapContainer = map.getContainer();
       const mapRect = mapContainer.getBoundingClientRect();

       popupContainerRef.current.style.left = `${point.x + mapRect.left}px`;
       popupContainerRef.current.style.top = `${point.y + mapRect.top - 10}px`;
     }
   };

   // Czyszczenie starych markerów
   if (markerClusterGroupRef.current) {
     markerClusterGroupRef.current.clearLayers();
   }
   markersRef.current = [];

   // Dodawanie nowych markerów dla lokali
   venues.forEach(venue => {
     if (!venue.lat || !venue.lng) return;

     const marker = window.L.marker([venue.lat, venue.lng], {
       icon: createPriceMarker(venue.price)
     });

     marker.on('click', (e) => {
       e.originalEvent.stopPropagation();
       
       if (isUnmountedRef.current || !popupRootRef.current || !popupContainerRef.current) return;
     
       if (activeVenueRef.current?.id !== venue.id) {
         activeVenueRef.current = {
           id: venue.id,
           lat: venue.lat,
           lng: venue.lng
         };
     
         popupRootRef.current.render(
           <VenuePopup
             spotId={venue.id}
             name={venue.name}
             beer={venue.beer}
             price={venue.price}
             rating={venue.rating}
             reviewCount={venue.reviewCount}
             address={venue.address}
             openingStatus="unknown"
             latitude={venue.lat}
             longitude={venue.lng}
             mapInstance={mapInstance.current}
             onClose={() => {
               if (popupContainerRef.current) {
                 popupContainerRef.current.style.display = 'none';
               }
               activeVenueRef.current = null;
             }}
           />
         );
       }
     
       popupContainerRef.current.style.display = 'block';
       updatePopupPosition();
     });

     markersRef.current.push(marker);
     if (markerClusterGroupRef.current) {
       markerClusterGroupRef.current.addLayer(marker);
     }
   });

   // Event handlers for map movement
   const handleMapMove = () => {
     if (!isUnmountedRef.current) {
       requestAnimationFrame(updatePopupPosition);
     }
   };

   const handleMapClick = (e: L.LeafletMouseEvent) => {
     if (isUnmountedRef.current) return;
     
     const target = e.originalEvent.target as HTMLElement;
     if (!target.closest('.leaflet-popup-fixed') && 
         !target.closest('.venue-popup') && 
         !target.closest('.custom-marker')) {
       if (popupContainerRef.current) {
         popupContainerRef.current.style.display = 'none';
       }
       activeVenueRef.current = null;
     }
   };

   map.on('move', handleMapMove);
   map.on('zoom', handleMapMove);
   map.on('moveend', handleMapMove);
   map.on('zoomend', handleMapMove);
   map.on('click', handleMapClick);
   window.addEventListener('resize', handleMapMove);

   return () => {
     map.off('move', handleMapMove);
     map.off('zoom', handleMapMove);
     map.off('moveend', handleMapMove);
     map.off('zoomend', handleMapMove);
     map.off('click', handleMapClick);
     window.removeEventListener('resize', handleMapMove);

     if (markerClusterGroupRef.current) {
       markerClusterGroupRef.current.clearLayers();
     }
   };
 }, [venues, mapReady, handleReviewsClick]);

 // Czyszczenie markera tymczasowego przy zmianie trybu lub lokalizacji
 useEffect(() => {
   if (!isAddMode || !selectedLocation) {
     if (tempMarkerRef.current) {
       tempMarkerRef.current.remove();
       tempMarkerRef.current = null;
     }
   }
 }, [isAddMode, selectedLocation]);

 return {
   markersRef,
   markerClusterGroupRef,
   tempMarkerRef,
   clearTempMarker: () => {
     if (tempMarkerRef.current) {
       tempMarkerRef.current.remove();
       tempMarkerRef.current = null;
     }
   }
 };
};

================
File: components/map/LocationAccuracyInfo.tsx
================
// src/app/components/map/LocationAccuracyInfo.tsx
import React from 'react';

interface LocationAccuracyInfoProps {
  accuracy: number | null;
  isLoading: boolean;
  error: string | null;
}

export const LocationAccuracyInfo: React.FC<LocationAccuracyInfoProps> = ({
  accuracy,
  isLoading,
  error
}) => {
  const getAccuracyLabel = (meters: number) => {
    if (meters < 10) return 'Bardzo wysoka';
    if (meters < 30) return 'Wysoka';
    if (meters < 100) return 'Średnia';
    return 'Niska';
  };

  if (isLoading) {
    return (
      <div className="absolute bottom-4 left-4 bg-white px-4 py-2 rounded-lg shadow-md z-[400]">
        <div className="flex items-center space-x-2">
          <div className="animate-spin rounded-full h-4 w-4 border-2 border-blue-500 border-t-transparent"></div>
          <span>Uzyskiwanie dokładnej lokalizacji...</span>
        </div>
      </div>
    );
  }

  if (accuracy) {
    const accuracyLabel = getAccuracyLabel(accuracy);
    const color = accuracy < 30 ? 'text-green-600' : accuracy < 100 ? 'text-yellow-600' : 'text-red-600';

    return (
      <div className="absolute bottom-4 left-4 bg-white px-4 py-2 rounded-lg shadow-md z-[400]">
        <div className="flex flex-col">
          <span className="text-sm text-gray-600">Dokładność lokalizacji:</span>
          <span className={`font-medium ${color}`}>
            {accuracyLabel} ({Math.round(accuracy)}m)
          </span>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="absolute bottom-4 left-4 bg-white px-4 py-2 rounded-lg shadow-md z-[400]">
        <span className="text-red-600">{error}</span>
      </div>
    );
  }

  return null;
};

================
File: components/map/LocationInfo.tsx
================
// src/app/components/map/LocationInfo.tsx
import React from 'react';

interface LocationInfoProps {
  error: string | null;
  isLoading: boolean;
  permissionStatus: string | null;
}

export const LocationInfo: React.FC<LocationInfoProps> = ({
  error,
  isLoading,
  permissionStatus
}) => {
  if (isLoading) {
    return (
      <div className="absolute top-4 right-4 bg-white px-4 py-2 rounded-lg shadow-md z-[400]">
        <div className="flex items-center space-x-2">
          <div className="animate-spin rounded-full h-4 w-4 border-2 border-amber-500 border-t-transparent"></div>
          <span>Ustalanie twojej lokalizacji...</span>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="absolute top-4 right-4 bg-white px-4 py-3 rounded-lg shadow-md z-[400] max-w-md">
        <div className="flex flex-col space-y-2">
          <div className="flex items-center space-x-2 text-amber-600">
            <svg className="w-5 h-5" fill="none" strokeWidth="1.5" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" d="M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z" />
            </svg>
            <span className="font-medium">Informacja o lokalizacji</span>
          </div>
          {error.split('\n').map((line, index) => (
            <p key={index} className="text-sm text-gray-600">
              {line}
            </p>
          ))}
          {permissionStatus && (
            <p className="text-xs text-gray-500 mt-2">
              Status uprawnień: {permissionStatus === 'granted' ? 'przyznane' : 
                               permissionStatus === 'denied' ? 'odrzucone' : 'nie określono'}
            </p>
          )}
          <button 
            onClick={() => window.location.reload()} 
            className="mt-2 px-4 py-2 bg-amber-50 text-amber-600 rounded-md hover:bg-amber-100 transition-colors text-sm font-medium"
          >
            Spróbuj ponownie
          </button>
        </div>
      </div>
    );
  }

  return null;
};

================
File: components/map/MapComponent.tsx
================
import React, { useRef, useState, useCallback, useEffect } from 'react';
import type { LeafletMouseEvent, Map as LeafletMap } from 'leaflet';
import { useGeolocation } from '../../hooks/useGeolocation';
import { useMapInitialization } from './hooks/useMapInitialization';
import { useVenueMarkers } from './hooks/useVenueMarkers';
import { LocationStatus } from './components/LocationStatus';
import { ReviewsModal } from './components/ReviewsModal';
import type { Venue } from '../../types';

interface MapComponentProps {
  venues: Venue[];
  onMapClick?: (e: LeafletMouseEvent) => void;
  isAddMode?: boolean;
  selectedLocation: {lat: number; lng: number} | null;
  onBoundsChanged?: (center: { 
    latitude: number; 
    longitude: number; 
    zoom: number 
  }) => void;
  onMapReady?: (map: LeafletMap) => void;
}

const MapComponent: React.FC<MapComponentProps> = ({
  venues,
  onMapClick,
  isAddMode = false,
  selectedLocation,
  onBoundsChanged,
  onMapReady
}) => {
  // Refs
  const mapRef = useRef<HTMLDivElement>(null!);
  const tempMarkerRef = useRef<L.Marker | null>(null);
  const markerClusterGroupRef = useRef<any>(null);

  // State
  const [isReviewsModalOpen, setReviewsModalOpen] = useState(false);
  const [selectedVenue, setSelectedVenue] = useState<Venue | null>(null);

  // Hooks
  const { latitude, longitude, isLoading, error, isDefault } = useGeolocation();

  // Initialize map
  const { mapInstance, mapReady } = useMapInitialization({
    mapRef,
    latitude,
    longitude,
    isDefault,
    onBoundsChanged,
    isAddMode,
    onMapClick: (e) => {
      if (onMapClick) {
        onMapClick(e);
      }
    }
  });

  // Handle map ready callback
  useEffect(() => {
    if (mapReady && mapInstance.current && onMapReady) {
      onMapReady(mapInstance.current);
    }
  }, [mapReady, onMapReady]);

  // Handle reviews modal
  const handleReviewsClick = useCallback(async (venue: Venue) => {
    setSelectedVenue(venue);
    setReviewsModalOpen(true);
  }, []);

  // Get markers refs from useVenueMarkers hook
  const { markersRef } = useVenueMarkers({
    mapInstance,
    mapReady,
    venues,
    handleReviewsClick,
    isAddMode,
    selectedLocation
  });

  // Reset map handler
  const handleMapReset = useCallback(() => {
    if (mapInstance.current && venues.length > 0) {
      try {
        // Save current view
        const currentBounds = mapInstance.current.getBounds();
        const currentZoom = mapInstance.current.getZoom();
        
        // Safely clear markers
        if (markerClusterGroupRef.current) {
          markerClusterGroupRef.current.clearLayers();
          
          // Check if markerClusterGroup needs reinitialization
          if (!markerClusterGroupRef.current.addEventParent) {
            markerClusterGroupRef.current = window.L.markerClusterGroup({
              maxClusterRadius: 50,
              spiderfyOnMaxZoom: true,
              showCoverageOnHover: true,
              zoomToBoundsOnClick: true,
              disableClusteringAtZoom: 16,
              chunkedLoading: true
            });
            mapInstance.current.addLayer(markerClusterGroupRef.current);
          }
        }

        // Recreate markers with existing data
        venues.forEach(venue => {
          try {
            const marker = window.L.marker([venue.lat, venue.lng], {
              icon: window.L.divIcon({
                className: 'custom-marker',
                html: `
                  <div style="
                    background-color: #D97706;
                    color: white;
                    border-radius: 20px;
                    padding: 6px 12px;
                    font-weight: bold;
                    font-size: 14px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                    border: 2px solid white;
                    white-space: nowrap;
                  ">
                    ${venue.price}
                  </div>
                `,
                iconSize: [40, 20],
                iconAnchor: [20, 10],
                popupAnchor: [0, -10]
              })
            });
            
            if (markersRef.current) {
              markersRef.current.push(marker);
            }
            if (markerClusterGroupRef.current) {
              markerClusterGroupRef.current.addLayer(marker);
            }
          } catch (error) {
            console.warn('Error creating marker:', error);
          }
        });

        // Restore view
        mapInstance.current.setView(currentBounds.getCenter(), currentZoom);
      } catch (error) {
        console.error('Error in handleMapReset:', error);
      }
    }
  }, [venues, mapInstance]);

  // Add event listener for map reset
  useEffect(() => {
    if (mapInstance.current && mapReady) {
      mapInstance.current.on('unload', handleMapReset);

      return () => {
        if (mapInstance.current) {
          mapInstance.current.off('unload', handleMapReset);
        }
      };
    }
  }, [handleMapReset, mapReady]);

  // Cleanup temporary marker when leaving add mode
  useEffect(() => {
    if (!isAddMode && tempMarkerRef.current) {
      tempMarkerRef.current.remove();
      tempMarkerRef.current = null;
    }
  }, [isAddMode]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (tempMarkerRef.current) {
        tempMarkerRef.current.remove();
        tempMarkerRef.current = null;
      }
    };
  }, []);

  return (
    <div className="relative h-full w-full">
      <div ref={mapRef} className="h-full w-full z-0" />
      
      <LocationStatus 
        isLoading={isLoading} 
        error={error} 
      />
      
      {selectedVenue && (
        <ReviewsModal
          isOpen={isReviewsModalOpen}
          onClose={() => setReviewsModalOpen(false)}
          spotId={selectedVenue.id}
          spotName={selectedVenue.name}
        />
      )}
    </div>
  );
};

export default MapComponent;

================
File: components/map/popups/AddBeerModal.tsx
================
// app/components/map/popups/AddBeerModal.tsx
import React, { useState } from 'react';
import { Dialog } from '@headlessui/react';
import { Beer, X } from 'lucide-react';

interface AddBeerModalProps {
  isOpen: boolean;
  onClose: () => void;
  venueName: string;
  spotId: number;
}

const AddBeerModal: React.FC<AddBeerModalProps> = ({ 
  isOpen, 
  onClose, 
  venueName, 
  spotId 
}) => {
  const [formData, setFormData] = useState({
    name: '',
    price: ''
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showSuccess, setShowSuccess] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError(null);

    const token = localStorage.getItem('authToken');
    if (!token) {
      setError('Musisz być zalogowany, aby dodać piwo');
      setIsSubmitting(false);
      return;
    }

    try {
      const response = await fetch(`https://piwo.jacolos.pl/api/beer-spots/${spotId}/beers`, {
        method: 'POST',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          name: formData.name,
          price: Number(formData.price),
        })
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.message || 'Wystąpił błąd podczas dodawania piwa');
      }

      setShowSuccess(true);
      setFormData({
        name: '',
        price: ''
      });

      setTimeout(() => {
        onClose();
        setShowSuccess(false);
      }, 2000);

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Wystąpił błąd podczas dodawania piwa');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Dialog open={isOpen} onClose={onClose} className="relative z-50">
      <div className="fixed inset-0 bg-black/30" aria-hidden="true" />
      <div className="fixed inset-0 flex items-center justify-center p-4">
        <Dialog.Panel className="bg-white rounded-lg shadow-xl max-w-md w-full">
          <div className="p-6 border-b">
            <div className="flex justify-between items-start">
              <div>
                <Dialog.Title className="text-xl font-bold text-gray-900">
                  Dodaj piwo
                </Dialog.Title>
                <p className="text-sm text-gray-600 mt-1">{venueName}</p>
              </div>
              <button onClick={onClose} className="text-gray-500 hover:text-gray-700">
                <X size={20} />
              </button>
            </div>
          </div>
          
          <form onSubmit={handleSubmit} className="p-6 space-y-6">
            {error && (
              <div className="bg-red-50 text-red-700 p-3 rounded-md mb-4">
                {error}
              </div>
            )}

            {showSuccess && (
              <div className="bg-green-50 text-green-700 p-3 rounded-md mb-4">
                Piwo zostało dodane pomyślnie!
              </div>
            )}

            <div className="space-y-2">
              <label className="block text-base font-medium text-gray-900">
                Nazwa piwa
              </label>
              <input
                type="text"
                value={formData.name}
                onChange={(e) => setFormData({...formData, name: e.target.value})}
                required
                className="w-full px-4 py-3 rounded-lg border border-gray-300 text-gray-900 text-base focus:ring-2 focus:ring-amber-500 focus:border-amber-500"
                placeholder="np. Tyskie Gronie"
              />
            </div>

            <div className="space-y-2">
              <label className="block text-base font-medium text-gray-900">
                Cena (zł)
              </label>
              <input
                type="number"
                step="0.01"
                value={formData.price}
                onChange={(e) => setFormData({...formData, price: e.target.value})}
                required
                className="w-full px-4 py-3 rounded-lg border border-gray-300 text-gray-900 text-base focus:ring-2 focus:ring-amber-500 focus:border-amber-500"
                placeholder="0.00"
              />
            </div>

            <div className="flex justify-end gap-3">
              <button
                type="button"
                onClick={onClose}
                className="px-4 py-2 text-gray-900 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors text-base font-medium"
              >
                Anuluj
              </button>
              <button
                type="submit"
                disabled={isSubmitting}
                className="px-4 py-2 bg-amber-600 text-white rounded-lg hover:bg-amber-700 transition-colors text-base font-medium flex items-center"
              >
                <Beer size={18} className="mr-2" />
                <span>{isSubmitting ? 'Dodawanie...' : 'Dodaj piwo'}</span>
              </button>
            </div>
          </form>
        </Dialog.Panel>
      </div>
    </Dialog>
  );
};

export default AddBeerModal;

================
File: components/map/popups/ReviewModal.tsx
================
// app/components/map/popups/ReviewModal.tsx
import React, { useState, useEffect } from 'react';
import { Dialog } from '@headlessui/react';
import { Star, X } from 'lucide-react';

interface Review {
  id: number;
  rating: number;
  comment: string;
  visit_date: string;
  created_at: string;
  user: {
    id: number;
    name: string;
  };
}

interface ReviewModalProps {
  isOpen: boolean;
  onClose: () => void;
  venueName: string;
  spotId: number;
}

const ReviewModal: React.FC<ReviewModalProps> = ({ 
  isOpen, 
  onClose, 
  venueName, 
  spotId 
}) => {
  const [rating, setRating] = useState(5);
  const [comment, setComment] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showSuccess, setShowSuccess] = useState(false);
  const [reviews, setReviews] = useState<Review[]>([]);
  const [isLoadingReviews, setIsLoadingReviews] = useState(false);
  const [reviewsError, setReviewsError] = useState<string | null>(null);

  useEffect(() => {
    if (!isOpen) return;

    const fetchReviews = async () => {
      setIsLoadingReviews(true);
      setReviewsError(null);

      try {
        const token = localStorage.getItem('authToken');
        if (!token) throw new Error('Musisz być zalogowany, aby zobaczyć opinie');

        const response = await fetch(`https://piwo.jacolos.pl/api/beer-spots/${spotId}/spot-reviews`, {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        if (!response.ok) throw new Error('Nie udało się pobrać opinii');
        
        const data = await response.json();
        setReviews(data.data.reviews || []);
      } catch (err) {
        setReviewsError(err instanceof Error ? err.message : 'Wystąpił błąd podczas pobierania opinii');
      } finally {
        setIsLoadingReviews(false);
      }
    };

    fetchReviews();
  }, [isOpen, spotId]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError(null);

    const token = localStorage.getItem('authToken');
    if (!token) {
      setError('Musisz być zalogowany, aby dodać opinię');
      setIsSubmitting(false);
      return;
    }

    const reviewData = {
      rating: Number(rating),
      comment: comment.trim(),
      visit_date: new Date().toISOString().split('T')[0]
    };

    try {
      const response = await fetch(`https://piwo.jacolos.pl/api/beer-spots/${spotId}/reviews`, {
        method: 'POST',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify(reviewData)
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || 'Wystąpił błąd podczas dodawania opinii');
      }

      setShowSuccess(true);
      setComment('');
      setRating(5);
      
      // Refresh reviews list
      const reviewsResponse = await fetch(`https://piwo.jacolos.pl/api/beer-spots/${spotId}/spot-reviews`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (reviewsResponse.ok) {
        const newData = await reviewsResponse.json();
        setReviews(newData.data.reviews || []);
      }

      setTimeout(() => {
        setShowSuccess(false);
      }, 2000);
      
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Wystąpił błąd podczas dodawania opinii');
    } finally {
      setIsSubmitting(false);
    }
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('pl-PL', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  };

  return (
    <Dialog open={isOpen} onClose={onClose} className="relative z-50">
      <div className="fixed inset-0 bg-black/30" aria-hidden="true" />
      <div className="fixed inset-0 flex items-center justify-center p-4">
        <Dialog.Panel className="bg-white rounded-lg shadow-xl max-w-md w-full">
          <div className="p-6 border-b">
            <div className="flex justify-between items-start">
              <Dialog.Title className="text-xl font-bold text-gray-900">
                Opinie dla {venueName}
              </Dialog.Title>
              <button onClick={onClose} className="text-gray-500 hover:text-gray-700">
                <X size={20} />
              </button>
            </div>
          </div>
          
          <div className="p-6">
            {/* Existing Reviews Section */}
            <div className="mb-6">
              {isLoadingReviews ? (
                <div className="flex justify-center items-center py-4">
                  <div className="animate-spin rounded-full h-8 w-8 border-2 border-amber-500 border-t-transparent"></div>
                </div>
              ) : reviewsError ? (
                <div className="bg-red-50 text-red-700 p-3 rounded-md mb-4">
                  {reviewsError}
                </div>
              ) : reviews.length > 0 ? (
                <div className="space-y-4">
                  {reviews.map((review) => (
                    <div key={review.id} className="border-b border-gray-100 pb-4">
                      <div className="flex justify-between items-start mb-2">
                        <div className="flex items-center space-x-2">
                          <div className="bg-amber-50 px-2 py-1 rounded-full">
                            <div className="flex items-center">
                              <Star size={16} className="text-amber-400" />
                              <span className="ml-1 font-medium text-amber-700">
                                {review.rating}
                              </span>
                            </div>
                          </div>
                          <span className="text-sm font-medium text-gray-900">
                            {review.user.name}
                          </span>
                        </div>
                        <span className="text-sm text-gray-500">
                          {formatDate(review.visit_date)}
                        </span>
                      </div>
                      <p className="text-gray-700">{review.comment}</p>
                    </div>
                  ))}
                </div>
              ) : (
                <p className="text-gray-500 text-center py-2">
                  Brak opinii dla tego miejsca
                </p>
              )}
            </div>

            {/* Add Review Form */}
            <div className="border-t pt-6">
              <h3 className="text-lg font-semibold text-gray-900 mb-4">
                Dodaj swoją opinię
              </h3>

              {error && (
                <div className="bg-red-50 text-red-700 p-3 rounded-md mb-4">
                  {error}
                </div>
              )}

              {showSuccess && (
                <div className="bg-green-50 text-green-700 p-3 rounded-md mb-4">
                  Dziękujemy za opinię! Została wysłana do moderacji.
                </div>
              )}

              <form onSubmit={handleSubmit} className="space-y-4">
                <div>
                  <label className="block text-base font-medium text-gray-900">
                    Ocena
                  </label>
                  <div className="flex items-center gap-2 mt-2">
                    {[1, 2, 3, 4, 5].map((value) => (
                      <button
                        key={value}
                        type="button"
                        onClick={() => setRating(value)}
                        className="p-1 rounded-full hover:bg-amber-50 transition-colors"
                      >
                        <Star 
                          size={28} 
                          className={value <= rating ? 'fill-amber-400 text-amber-400' : 'text-gray-300'} 
                        />
                      </button>
                    ))}
                    <span className="ml-2 text-sm text-gray-600">
                      ({rating}/5)
                    </span>
                  </div>
                </div>

                <div>
                  <label className="block text-base font-medium text-gray-900">
                    Twój komentarz
                  </label>
                  <textarea
                    value={comment}
                    onChange={(e) => setComment(e.target.value)}
                    required
                    className="mt-2 w-full px-4 py-3 rounded-lg border border-gray-300 text-gray-900 text-base focus:ring-2 focus:ring-amber-500 focus:border-amber-500 h-32 resize-none"
                    placeholder="Opisz swoje doświadczenia..."
                  />
                </div>

                <div className="flex justify-end gap-3">
                  <button
                    type="button"
                    onClick={onClose}
                    className="px-4 py-2 text-gray-900 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors text-base font-medium"
                  >
                    Anuluj
                  </button>
                  <button
                    type="submit"
                    disabled={isSubmitting}
                    className="px-4 py-2 bg-amber-600 text-white rounded-lg hover:bg-amber-700 transition-colors text-base font-medium"
                  >
                    {isSubmitting ? 'Wysyłanie...' : 'Wyślij opinię'}
                  </button>
                </div>
              </form>
            </div>
          </div>
        </Dialog.Panel>
      </div>
    </Dialog>
  );
};

export default ReviewModal;

================
File: components/map/popups/VenuePopup.tsx
================
import React, { useState, useEffect } from 'react';
import { Star, Heart, Beer, Clock, MapPin, Flag, X } from 'lucide-react';
import { useFavoritesStore } from '../../../stores/useFavoritesStore';
import ReviewModal from './ReviewModal';
import AddBeerModal from './AddBeerModal';
import ReportForm from '../../forms/ReportForm';
import { ensurePopupVisible } from '../utils/mapCentering';

interface VenuePopupProps {
  spotId: number;
  name: string;
  beer?: string;
  price?: string;
  rating?: number;
  reviewCount?: number;
  address?: string;
  openingStatus?: 'open' | 'closed' | 'unknown';
  latitude: number;
  longitude: number;
  mapInstance?: L.Map | null;
  onClose?: () => void;
}

const VenuePopup: React.FC<VenuePopupProps> = ({
  spotId,
  name,
  beer = 'Nieznane',
  price = 'Brak ceny',
  rating = 0,
  reviewCount = 0,
  address,
  openingStatus = 'unknown',
  latitude,
  longitude,
  mapInstance,
  onClose
}) => {
  const [isHovered, setIsHovered] = useState(false);
  const [isReviewModalOpen, setReviewModalOpen] = useState(false);
  const [isAddBeerModalOpen, setAddBeerModalOpen] = useState(false);
  const [isReportModalOpen, setReportModalOpen] = useState(false);
  const { toggleFavorite, isFavorite } = useFavoritesStore();
  const [isFavoriteLocal, setIsFavoriteLocal] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    setIsFavoriteLocal(isFavorite(spotId));
  }, [spotId, isFavorite]);

  // Nowy useEffect do centrowania popupu
  useEffect(() => {
    if (mapInstance && latitude && longitude) {
      const position = { lat: latitude, lng: longitude };
      
      // Najpierw wycentruj mapę na lokalizacji
      mapInstance.setView(position, mapInstance.getZoom(), {
        animate: true,
        duration: 0.5
      });

      // Następnie dostosuj pozycję, aby popup był całkowicie widoczny
      setTimeout(() => {
        ensurePopupVisible({
          map: mapInstance,
          lat: latitude,
          lng: longitude,
          popupHeight: 400,
          popupWidth: 280,
          padding: 50
        });
      }, 100);
    }
  }, [mapInstance, latitude, longitude]);

  // Efekt czyszczący
  useEffect(() => {
    return () => {
      setReviewModalOpen(false);
      setAddBeerModalOpen(false);
      setReportModalOpen(false);
    };
  }, []);

  const handleFavoriteToggle = async () => {
    const token = localStorage.getItem('authToken');
    if (!token) {
      alert('Musisz być zalogowany, aby dodać do ulubionych');
      return;
    }

    setIsLoading(true);
    try {
      const spotData = {
        id: spotId,
        name,
        address: address || '',
        latitude,
        longitude,
        average_rating: rating,
        beers: [{
          name: beer,
          price: parseFloat(price.replace(/[^\d.-]/g, '')) || 0
        }]
      };

      const newIsFavorite = await toggleFavorite(spotId, spotData);
      setIsFavoriteLocal(newIsFavorite);
    } finally {
      setIsLoading(false);
    }
  };

  const getOpeningStatusLabel = (status: string) => {
    switch (status) {
      case 'open':
        return <span className="text-green-600 font-medium">Otwarte</span>;
      case 'closed':
        return <span className="text-red-600 font-medium">Zamknięte</span>;
      default:
        return <span className="text-gray-600">Godziny nieznane</span>;
    }
  };

  const handleClose = () => {
    if (onClose) {
      onClose();
    }
    if (mapInstance) {
      mapInstance.closePopup();
    }
  };

  return (
    <>
      <div 
        className="venue-popup bg-white rounded-lg overflow-hidden shadow-lg z-[25]"
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
      >
        {/* Header */}
        <div className="p-3 border-b">
          <div className="flex justify-between items-start">
            <h3 className="text-lg font-bold text-gray-900">{name}</h3>
            <div className="flex gap-2">
              <button 
                onClick={handleFavoriteToggle}
                disabled={isLoading}
                className={`p-1.5 rounded-full transition-colors ${
                  isHovered ? 'bg-gray-100' : ''
                }`}
              >
                <Heart 
                  size={20} 
                  className={`transition-colors ${
                    isFavoriteLocal ? 'fill-red-500 text-red-500' : 'text-gray-400'
                  } ${isLoading ? 'opacity-50' : ''}`}
                />
              </button>
              {onClose && (
                <button 
                  onClick={handleClose}
                  className="p-1.5 rounded-full transition-colors hover:bg-gray-100"
                >
                  <X size={20} className="text-gray-500" />
                </button>
              )}
            </div>
          </div>
        </div>

        {/* Content */}
        <div className="p-3 space-y-2">
          <div className="flex items-center justify-between">
            <div className="flex items-center text-gray-900">
              <Beer size={18} className="mr-2 text-gray-800" />
              <span className="font-medium">{beer}</span>
            </div>
            <span className="font-bold text-amber-600">{price}</span>
          </div>

          <div className="flex items-center space-x-3">
            <div className="flex items-center bg-amber-50 px-2 py-1 rounded-full">
              <Star size={16} className="text-amber-400 mr-1" />
              <span className="font-medium text-amber-700">{rating.toFixed(1)}</span>
            </div>
            <button
              onClick={() => setReviewModalOpen(true)}
              className="text-sm text-gray-900 hover:text-amber-600 transition-colors font-medium"
            >
              {reviewCount} {reviewCount === 1 ? 'opinia' : 'opinii'}
            </button>
          </div>

          <div className="flex items-center text-gray-900">
            <Clock size={16} className="mr-2 text-gray-800" />
            {getOpeningStatusLabel(openingStatus)}
          </div>

          <div className="flex items-center text-gray-900">
            <MapPin size={16} className="mr-2 text-gray-800 flex-shrink-0" />
            <span className="line-clamp-2">{address}</span>
          </div>
        </div>

        {/* Actions */}
        <div className="p-3 bg-gray-50 border-t grid grid-cols-3 gap-2">
          <button
            onClick={() => setAddBeerModalOpen(true)}
            className="flex items-center justify-center px-3 py-2 bg-amber-600 text-white rounded-lg hover:bg-amber-700 transition-colors font-medium"
          >
            <Beer size={16} className="mr-1" />
            <span>Dodaj piwo</span>
          </button>
          
          <button
            onClick={() => {
              const url = `https://www.google.com/maps/dir/?api=1&destination=${latitude},${longitude}`;
              window.open(url, '_blank');
            }}
            className="flex items-center justify-center px-3 py-2 bg-gray-200 text-gray-900 rounded-lg hover:bg-gray-300 transition-colors font-medium"
          >
            <MapPin size={16} className="mr-1" />
            <span>Nawiguj</span>
          </button>

          <button
            onClick={() => setReportModalOpen(true)}
            className="flex items-center justify-center px-3 py-2 bg-gray-200 text-gray-900 rounded-lg hover:bg-gray-300 transition-colors font-medium"
          >
            <Flag size={16} className="mr-1" />
            <span>Zgłoś</span>
          </button>
        </div>
      </div>

      {/* Modals */}
      <ReviewModal 
        isOpen={isReviewModalOpen}
        onClose={() => setReviewModalOpen(false)}
        venueName={name}
        spotId={spotId}
      />

      <AddBeerModal
        isOpen={isAddBeerModalOpen}
        onClose={() => setAddBeerModalOpen(false)}
        venueName={name}
        spotId={spotId}
      />

      <ReportForm 
        isOpen={isReportModalOpen}
        onClose={() => setReportModalOpen(false)}
        spotId={spotId}
        venueName={name}
      />
    </>
  );
};

export default VenuePopup;

================
File: components/map/utils/api.ts
================
// src/app/components/map/utils/api.ts
interface ApiReview {
    id: number;
    rating: number;
    comment: string;
    visit_date: string;
    created_at: string;
    user: {
      id: number;
      name: string;
    };
  }
  
  interface ApiResponse {
    data: {
      spot_id: number;
      spot_name: string;
      average_rating: number;
      total_reviews: number;
      reviews: ApiReview[];
    };
  }
  
  export const fetchReviews = async (venueId: number, token: string | null) => {
    try {
      const response = await fetch(`https://piwo.jacolos.pl/api/beer-spots/${venueId}/spot-reviews`, {
        headers: {
          'Content-Type': 'application/json',
          ...(token ? { 'Authorization': `Bearer ${token}` } : {})
        }
      });
      
      if (!response.ok) throw new Error('Nie udało się pobrać opinii');
      const responseData: ApiResponse = await response.json();
      
      return responseData.data.reviews;
    } catch (err) {
      console.error('Error fetching reviews:', err);
      throw err;
    }
  };

================
File: components/map/utils/helpers.ts
================
// src/app/components/map/utils/helpers.ts
export const getReviewsCount = (count: number) => {
    if (count === 1) return '1 opinia';
    if (count === 0) return '0 opinii';
    if (count % 10 >= 2 && count % 10 <= 4 && (count % 100 < 10 || count % 100 >= 20)) return `${count} opinie`;
    return `${count} opinii`;
  };

================
File: components/map/utils/mapCentering.ts
================
import type { Map as LeafletMap } from 'leaflet';

interface CenterPopupOptions {
  map: LeafletMap;
  lat: number;
  lng: number;
  padding?: number;
  popupHeight?: number;
  popupWidth?: number;
}

export const ensurePopupVisible = ({
  map,
  lat,
  lng,
  padding = 50,
  popupHeight = 400,
  popupWidth = 280
}: CenterPopupOptions) => {
  // Convert the lat/lng to pixel coordinates
  const point = map.latLngToContainerPoint([lat, lng]);
  
  // Get the map container bounds
  const mapSize = map.getSize();
  
  // Calculate necessary offsets to keep popup visible
  let offsetX = 0;
  let offsetY = 0;
  
  // Check horizontal bounds (including popup width)
  if (point.x - (popupWidth / 2) < padding) {
    offsetX = padding - (point.x - (popupWidth / 2));
  } else if (point.x + (popupWidth / 2) > mapSize.x - padding) {
    offsetX = (mapSize.x - padding) - (point.x + (popupWidth / 2));
  }
  
  // Check vertical bounds (popup appears above the point)
  if (point.y - popupHeight < padding) {
    offsetY = padding - (point.y - popupHeight);
  } else if (point.y > mapSize.y - padding) {
    offsetY = (mapSize.y - padding) - point.y;
  }
  
  // If we need to adjust the position, do it smoothly
  if (offsetX !== 0 || offsetY !== 0) {
    map.panBy([-offsetX, -offsetY], {
      animate: true,
      duration: 0.25,
      easeLinearity: 0.25
    });
  }
};

================
File: components/map/utils/markers.ts
================
// src/app/components/map/utils/markers.ts
export const createPriceMarker = (price: string, isTemp = false) => {
    const L = window.L;
    return L.divIcon({
      className: 'custom-marker',
      html: `
        <div style="
          background-color: ${isTemp ? '#FCD34D' : '#D97706'};
          color: white;
          border-radius: 20px;
          padding: 6px 12px;
          font-weight: bold;
          font-size: 14px;
          display: flex;
          align-items: center;
          justify-content: center;
          box-shadow: 0 2px 4px rgba(0,0,0,0.2);
          border: 2px solid white;
          white-space: nowrap;
        ">
          ${price}
        </div>
      `,
      iconSize: [40, 20],
      iconAnchor: [20, 10],
      popupAnchor: [0, -10]
    });
  };
  
  export const createUserLocationMarker = () => {
    const L = window.L;
    return L.divIcon({
      className: 'user-location-marker',
      html: `
        <div style="position: relative;">
          <div style="
            position: absolute;
            top: -12px;
            left: -12px;
            background-color: #3B82F6;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.3);
            border: 2px solid white;
          ">
            <div style="
              width: 8px;
              height: 8px;
              background: white;
              border-radius: 50%;
            "></div>
          </div>
        </div>
      `,
      iconSize: [0, 0],
      iconAnchor: [0, 0],
    });
  };

================
File: components/reviews/ReviewForm.tsx
================
import React, { useState, useEffect } from 'react';
import { Star } from 'lucide-react';

interface ReviewFormProps {
  spotId: number;
  token: string | null;
  onSuccess: () => void;
  onClose?: () => void;
}

export const ReviewForm: React.FC<ReviewFormProps> = ({ spotId, token, onSuccess, onClose }) => {
  const [rating, setRating] = useState<number>(5);
  const [comment, setComment] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showSuccess, setShowSuccess] = useState(false);
  const [hasExistingReview, setHasExistingReview] = useState(false);

// Check if user has already reviewed this spot
useEffect(() => {
    const checkExistingReview = async () => {
      if (!token) return;
  
      try {
        const response = await fetch(`https://piwo.jacolos.pl/api/beer-spots/${spotId}/spot-reviews`, {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });
  
        if (!response.ok) return;
        
        const data = await response.json();
  
        let userId: string | null = null;
        try {
          const payload = token.split('.')[1];
          if (payload) {
            userId = JSON.parse(atob(payload)).sub || null;
          }
        } catch {
          console.error('Error decoding token');
        }
  
        if (userId) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const userReviews = data.data.reviews.filter((review: any) => review.user.id === userId);
          setHasExistingReview(userReviews.length > 0);
        }
      } catch (err) {
        console.error('Error checking existing review:', err);
      }
    };
  
    checkExistingReview();
  }, [spotId, token]);  

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!token) {
      setError('Musisz być zalogowany, aby dodać opinię');
      return;
    }

    if (hasExistingReview) {
      setError('Już dodałeś opinię dla tego miejsca, jeśli jeszcze jej nie widać, poczekaj na akceptacje.');
      return;
    }

    setIsSubmitting(true);
    setError(null);

    try {
      const response = await fetch(`https://piwo.jacolos.pl/api/beer-spots/${spotId}/reviews`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          rating,
          comment,
          visit_date: new Date().toISOString().split('T')[0]
        })
      });

      if (!response.ok) {
        throw new Error('Już dodałeś opinię dla tego miejsca, jeśli jeszcze jej nie widać, poczekaj na akceptacje.');
      }

      setShowSuccess(true);
      setComment('');
      setRating(5);
      setTimeout(() => {
        setShowSuccess(false);
        onSuccess();
        if (onClose) onClose();
      }, 2000);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Wystąpił błąd podczas dodawania opinii');
    } finally {
      setIsSubmitting(false);
    }
  };

  if (hasExistingReview) {
    return (
      <div className="border-t border-gray-200 mt-6 pt-6">
        <div className="bg-amber-50 text-amber-800 p-4 rounded-md">
          Już dodałeś opinię dla tego miejsca. Możesz dodać tylko jedną opinię.
        </div>
      </div>
    );
  }

  return (
    <div className="border-t border-gray-200 mt-6 pt-6">
      <h3 className="text-lg font-semibold text-gray-900 mb-4">Dodaj swoją opinię</h3>
      
      {showSuccess ? (
        <div className="bg-green-50 text-green-700 p-4 rounded-md mb-4">
          Dziękujemy za opinię! Została wysłana do moderacji.
        </div>
      ) : (
        <form onSubmit={handleSubmit}>
          {error && (
            <div className="bg-red-50 text-red-700 p-3 rounded-md mb-4">
              {error}
            </div>
          )}

          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-900 mb-1">
              Ocena
            </label>
            <div className="flex items-center gap-2">
              {[1, 2, 3, 4, 5].map((value) => (
                <button
                  key={value}
                  type="button"
                  onClick={() => setRating(value)}
                  className={`p-1 rounded-full hover:bg-amber-50 transition-colors ${
                    value <= rating ? 'text-amber-400' : 'text-gray-300'
                  }`}
                >
                  <Star className="w-8 h-8 fill-current" />
                </button>
              ))}
              <span className="ml-2 text-gray-900">({rating}/5)</span>
            </div>
          </div>

          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-900 mb-1">
              Komentarz
            </label>
            <textarea
              value={comment}
              onChange={(e) => setComment(e.target.value)}
              required
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-amber-500 focus:border-amber-500 text-gray-900 placeholder-gray-500"
              rows={4}
              placeholder="Napisz swoją opinię..."
            />
          </div>

          <button
            type="submit"
            disabled={isSubmitting || hasExistingReview}
            className="w-full bg-amber-600 text-white py-2 px-4 rounded-md hover:bg-amber-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-amber-500 disabled:opacity-50"
          >
            {isSubmitting ? 'Wysyłanie...' : 'Wyślij opinię'}
          </button>
        </form>
      )}
    </div>
  );
};

export default ReviewForm;

================
File: components/venues/VenueCard.tsx
================
import React, { useState } from 'react';
import { MapPin, Beer, Star, MessageSquare } from 'lucide-react';
import { Dialog } from '@headlessui/react';
import { X } from 'lucide-react';
import { useAuth } from '../../hooks/useAuth';
import { ReviewForm } from '../reviews/ReviewForm';

interface ApiReview {
  id: number;
  rating: number;
  comment: string;
  visit_date: string;
  created_at: string;
  user: {
    id: number;
    name: string;
  };
}

interface ApiResponse {
  data: {
    spot_id: number;
    spot_name: string;
    average_rating: number;
    total_reviews: number;
    reviews: ApiReview[];
  };
}

interface Venue {
  id: number;
  name: string;
  beer: string;
  price: string;
  rating: number;
  reviewCount: number;
  lat: number;
  lng: number;
  address?: string;
  distance: number;
}

export const VenueCard: React.FC<{ venue: Venue }> = ({ venue }) => {
  const [isReviewsModalOpen, setReviewsModalOpen] = useState(false);
  const [reviews, setReviews] = useState<ApiReview[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { token } = useAuth();

  const formatDistance = (distance: number) => {
    if (distance < 1) {
      return `${(distance * 1000).toFixed(0)}m`;
    }
    return `${distance.toFixed(1)}km`;
  };

  const fetchReviews = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch(`https://piwo.jacolos.pl/api/beer-spots/${venue.id}/spot-reviews`, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (!response.ok) throw new Error('Nie udało się pobrać opinii');
      const responseData: ApiResponse = await response.json();
      
      if (responseData.data && Array.isArray(responseData.data.reviews)) {
        setReviews(responseData.data.reviews);
      } else {
        setReviews([]);
      }
    } catch (err) {
      console.error('Error fetching reviews:', err);
      setError(err instanceof Error ? err.message : 'Wystąpił błąd podczas pobierania opinii');
      setReviews([]);
    } finally {
      setIsLoading(false);
    }
  };

  const handleReviewsClick = () => {
    setReviewsModalOpen(true);
    fetchReviews();
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('pl-PL', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  };

  const getReviewsCount = (count: number) => {
    if (count === 1) return '1 opinia';
    if (count === 0) return '0 opinii';
    if (count % 10 >= 2 && count % 10 <= 4 && (count % 100 < 10 || count % 100 >= 20)) return `${count} opinie`;
    return `${count} opinii`;
  };

  return (
    <>
      <div className="bg-white rounded-lg shadow-sm border border-gray-200 p-4 hover:shadow-md transition-shadow">
        <div className="flex justify-between items-start">
          <div className="flex-1">
            <h3 className="text-xl font-bold text-gray-900 mb-2">
              {venue.name}
            </h3>
            <div className="flex items-center text-gray-900 mb-2">
              <Beer className="w-4 h-4 mr-2" />
              <span className="font-medium">Piwo: {venue.beer}</span>
              <span className="mx-2">•</span>
              <span className="font-bold text-amber-600">{venue.price}</span>
            </div>
            <div className="flex items-center text-gray-700 gap-4">
              {venue.address && (
                <div className="flex items-center">
                  <MapPin className="w-4 h-4 mr-2" />
                  <span>{venue.address}</span>
                </div>
              )}
              <div className="flex items-center text-amber-600 font-medium">
                <span>{formatDistance(venue.distance)}</span>
              </div>
            </div>
          </div>
          <div className="flex flex-col items-end gap-2">
            <div className="flex items-center bg-amber-50 px-3 py-1 rounded-full">
              <Star className="w-5 h-5 text-amber-400 mr-1" />
              <span className="font-bold text-amber-700">{venue.rating.toFixed(1)}</span>
            </div>
            <button
              onClick={handleReviewsClick}
              className="flex items-center px-3 py-1 bg-gray-50 text-gray-600 rounded-full hover:bg-gray-100 transition-colors"
            >
              <MessageSquare className="w-4 h-4 mr-1" />
              <span>{getReviewsCount(venue.reviewCount)}</span>
            </button>
          </div>
        </div>
      </div>

      <Dialog open={isReviewsModalOpen} onClose={() => setReviewsModalOpen(false)} className="relative z-50">
        <div className="fixed inset-0 bg-black/30" aria-hidden="true" />
        
        <div className="fixed inset-0 flex items-center justify-center p-4">
          <Dialog.Panel className="bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[80vh] flex flex-col">
            <div className="p-6 border-b">
              <div className="flex justify-between items-start">
                <div>
                  <Dialog.Title className="text-2xl font-bold text-gray-900">
                    Opinie o {venue.name}
                  </Dialog.Title>
                  <p className="text-gray-600 mt-1">
                    {getReviewsCount(reviews.length)}
                  </p>
                </div>
                <button
                  onClick={() => setReviewsModalOpen(false)}
                  className="text-gray-400 hover:text-gray-500"
                >
                  <X size={24} />
                </button>
              </div>
            </div>

            <div className="flex-1 overflow-y-auto p-6">
              {isLoading ? (
                <div className="flex justify-center items-center h-32">
                  <div className="animate-spin rounded-full h-8 w-8 border-2 border-amber-500 border-t-transparent"></div>
                </div>
              ) : error ? (
                <div className="text-center text-red-600 p-4">
                  {error}
                </div>
              ) : reviews.length === 0 ? (
                <div className="text-center text-gray-500 p-4">
                  Brak opinii dla tego miejsca
                </div>
              ) : (
                <div className="space-y-6">
                  {reviews.map((review) => (
                    <div key={review.id} className="border-b border-gray-100 pb-6 last:border-0">
                      <div className="flex justify-between items-start mb-2">
                        <div className="flex items-center">
                          <div className="bg-amber-50 px-3 py-1 rounded-full flex items-center">
                            <Star className="w-4 h-4 text-amber-400 mr-1" />
                            <span className="font-bold text-amber-700">{review.rating.toFixed(1)}</span>
                          </div>
                        </div>
                        <span className="text-sm text-gray-500">
                          {formatDate(review.visit_date)}
                        </span>
                      </div>
                      <p className="text-gray-700 mb-2">{review.comment}</p>
                      <p className="text-sm text-gray-500">
                        {review.user.name}
                      </p>
                    </div>
                  ))}
                </div>
              )}

              {/* Add Review Form */}
              <ReviewForm 
                spotId={venue.id}
                token={token}
                onSuccess={() => {
                  fetchReviews();
                }}
              />
            </div>
          </Dialog.Panel>
        </div>
      </Dialog>
    </>
  );
};

================
File: components/venues/VenueList.tsx
================
import React, { useState } from 'react';
import { Star, Heart, MapPin, Beer, Loader2, Clock } from 'lucide-react';
import { useFavoritesStore } from '../../stores/useFavoritesStore';
import { useAuth } from '../../hooks/useAuth';

const LoadingState = () => (
  <div className="min-h-[400px] flex items-center justify-center">
    <div className="flex flex-col items-center gap-4">
      <Loader2 className="h-12 w-12 animate-spin text-amber-500" />
      <p className="text-gray-600 font-medium">Szukam najlepszych lokali w okolicy...</p>
    </div>
  </div>
);

const ErrorState = ({ error }: { error: string }) => (
  <div className="min-h-[200px] flex items-center justify-center">
    <div className="bg-red-50 text-red-700 px-6 py-4 rounded-lg max-w-md text-center">
      <p className="font-medium">{error}</p>
    </div>
  </div>
);

const EmptyState = () => (
  <div className="min-h-[300px] flex items-center justify-center">
    <div className="text-center">
      <Beer className="w-16 h-16 text-gray-300 mx-auto mb-4" />
      <h3 className="text-lg font-medium text-gray-900 mb-2">
        Brak lokali w okolicy
      </h3>
      <p className="text-gray-600">
        Spróbuj zmienić kryteria wyszukiwania lub lokalizację
      </p>
    </div>
  </div>
);
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const VenueCard = ({ venue }: { venue: any }) => {
  const { isAuthenticated } = useAuth();
  const { 
    toggleFavorite, 
    isFavorite,
    canAddMore 
  } = useFavoritesStore();
  const [isTogglingFavorite, setIsTogglingFavorite] = useState(false);

  const handleFavoriteClick = async (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    
    if (!isAuthenticated) {
      // You might want to trigger auth modal here
      alert('Musisz być zalogowany, aby dodać do ulubionych');
      return;
    }

    if (!isFavorite(venue.id) && !canAddMore()) {
      alert('Osiągnięto limit ulubionych miejsc. Usuń niektóre, aby dodać nowe.');
      return;
    }

    setIsTogglingFavorite(true);
    try {
      await toggleFavorite(venue.id, {
        id: venue.id,
        name: venue.name,
        address: venue.address || '',
        latitude: venue.lat,
        longitude: venue.lng,
        average_rating: venue.rating,
        beers: [{
          name: venue.beer,
          price: parseFloat(venue.price.replace(/[^\d.-]/g, '')) || 0
        }]
      });
    } finally {
      setIsTogglingFavorite(false);
    }
  };

  const handleNavigate = () => {
    window.open(
      `https://www.google.com/maps/dir/?api=1&destination=${venue.lat},${venue.lng}`,
      '_blank'
    );
  };

  return (
    <div className="bg-white rounded-lg shadow-sm border border-gray-200 transition-all hover:shadow-md overflow-hidden">
      <div className="p-4 sm:p-6">
        <div className="flex items-start justify-between gap-4">
          <div className="flex-1 min-w-0">
            <div className="flex items-center gap-2 mb-2">
              <h3 className="text-lg font-bold text-gray-900 truncate">
                {venue.name}
              </h3>
              <button
                onClick={handleFavoriteClick}
                disabled={isTogglingFavorite}
                className={`p-1 rounded-full transition-colors ${
                  isTogglingFavorite ? 'opacity-50' : ''
                }`}
              >
                <Heart 
                  size={20} 
                  className={`transition-colors ${
                    isFavorite(venue.id) 
                      ? 'fill-red-500 text-red-500' 
                      : 'text-gray-400 hover:text-red-500'
                  }`}
                />
              </button>
            </div>

            <div className="flex items-center text-gray-900 mb-3">
              <Beer className="w-4 h-4 mr-2 flex-shrink-0" />
              <span className="font-medium truncate">{venue.beer}</span>
              <span className="mx-2">•</span>
              <span className="font-bold text-amber-600">{venue.price}</span>
            </div>

            {venue.address && (
              <div className="flex items-center text-gray-600 mb-3">
                <MapPin className="w-4 h-4 mr-2 flex-shrink-0" />
                <span className="truncate">{venue.address}</span>
              </div>
            )}

            <div className="flex flex-wrap items-center gap-2">
              <div className="flex items-center bg-amber-50 px-3 py-1 rounded-full">
                <Star className="w-4 h-4 text-amber-400 mr-1" />
                <span className="font-bold text-amber-700">
                  {venue.rating.toFixed(1)}
                </span>
              </div>

              <div className="flex items-center text-gray-600">
                <Clock className="w-4 h-4 mr-1" />
                <span className="text-sm">Otwarte</span>
              </div>

              <div className="flex items-center text-amber-600 font-medium">
                <span>{(venue.distance < 1 
                  ? `${(venue.distance * 1000).toFixed(0)}m`
                  : `${venue.distance.toFixed(1)}km`)}</span>
              </div>
            </div>
          </div>

          <div className="flex flex-col items-end gap-2">
            <button
              onClick={handleNavigate}
              className="flex items-center gap-2 px-3 py-1.5 bg-amber-50 text-amber-600 rounded-full hover:bg-amber-100 transition-colors whitespace-nowrap"
            >
              <MapPin className="w-4 h-4" />
              <span className="hidden sm:inline">Nawiguj</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export const VenueList = ({ 
  venues, 
  isLoading, 
  error 
}: { 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
  venues: any[];
  isLoading: boolean;
  error: string | null;
}) => {
  const nearestVenues = venues.slice(0, 40);

  if (isLoading) {
    return <LoadingState />;
  }

  if (error) {
    return <ErrorState error={error} />;
  }

  if (venues.length === 0) {
    return <EmptyState />;
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h2 className="text-lg font-semibold text-gray-900">
          Lokale w pobliżu
        </h2>
        <span className="text-sm text-gray-600">
          Pokazuje {nearestVenues.length} najbliższych lokali
        </span>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
        {nearestVenues.map(venue => (
          <VenueCard key={venue.id} venue={venue} />
        ))}
      </div>
    </div>
  );
};

================
File: components/venues/VenuePopupActions.tsx
================
import React, { useState } from 'react';
import { Dialog } from '@headlessui/react';
// eslint-disable-next-line @typescript-eslint/no-unused-vars
import { Flag, Beer, X, Camera, Upload } from 'lucide-react';

const VenuePopupActions = () => {
  const [isReportModalOpen, setReportModalOpen] = useState(false);
  const [isAddBeerModalOpen, setAddBeerModalOpen] = useState(false);
  const [previewImage, setPreviewImage] = useState<string | null>(null);
  const [isDragging, setIsDragging] = useState(false);

  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        setPreviewImage(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  };

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
    const file = e.dataTransfer.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        setPreviewImage(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  };

  return (
    <div className="space-y-4">
      <div className="flex gap-2">
        <button 
          onClick={() => setAddBeerModalOpen(true)}
          className="flex-1 px-4 py-2 bg-gradient-to-r from-amber-500 to-amber-600 text-white rounded-lg hover:from-amber-600 hover:to-amber-700 transition-all shadow-md hover:shadow-lg flex items-center justify-center gap-2"
        >
          <Beer size={18} />
          <span>Dodaj piwo</span>
        </button>

        <button 
          onClick={() => setReportModalOpen(true)}
          className="px-4 py-2 bg-gray-100 text-gray-600 rounded-lg hover:bg-gray-200 transition-all flex items-center justify-center"
        >
          <Flag size={18} />
        </button>
      </div>

      {/* Report Modal */}
      <Dialog open={isReportModalOpen} onClose={() => setReportModalOpen(false)} className="relative z-50">
        <div className="fixed inset-0 bg-black/30 backdrop-blur-sm" aria-hidden="true" />
        
        <div className="fixed inset-0 flex items-center justify-center p-4">
          <Dialog.Panel className="bg-white rounded-2xl shadow-xl max-w-md w-full">
            <div className="p-6">
              <div className="flex justify-between items-center mb-6">
                <Dialog.Title className="text-xl font-bold text-gray-900">
                  Zgłoś problem
                </Dialog.Title>
                <button
                  onClick={() => setReportModalOpen(false)}
                  className="text-gray-400 hover:text-gray-500 p-1 hover:bg-gray-100 rounded-full transition-colors"
                >
                  <X size={20} />
                </button>
              </div>

              <form className="space-y-6">
                <div>
                  <label className="block text-sm font-medium text-gray-900 mb-2">
                    Co jest nie tak?
                  </label>
                  <textarea 
                    className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-amber-500 focus:border-amber-500 h-32 resize-none text-gray-900 placeholder-gray-500 bg-white"
                    placeholder="Opisz problem który zauważyłeś..."
                  />
                </div>

                <button
                  type="submit"
                  className="w-full bg-gradient-to-r from-amber-500 to-amber-600 text-white py-3 px-4 rounded-xl hover:from-amber-600 hover:to-amber-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-amber-500 shadow-md hover:shadow-lg transition-all font-medium"
                >
                  Wyślij zgłoszenie
                </button>
              </form>
            </div>
          </Dialog.Panel>
        </div>
      </Dialog>

      {/* Add Beer Modal */}
      <Dialog open={isAddBeerModalOpen} onClose={() => setAddBeerModalOpen(false)} className="relative z-50">
        <div className="fixed inset-0 bg-black/30 backdrop-blur-sm" aria-hidden="true" />
        
        <div className="fixed inset-0 flex items-center justify-center p-4">
          <Dialog.Panel className="bg-white rounded-2xl shadow-xl max-w-md w-full">
            <div className="p-6">
              <div className="flex justify-between items-center mb-6">
                <Dialog.Title className="text-xl font-bold text-gray-900">
                  Dodaj nowe piwo
                </Dialog.Title>
                <button
                  onClick={() => setAddBeerModalOpen(false)}
                  className="text-gray-400 hover:text-gray-500 p-1 hover:bg-gray-100 rounded-full transition-colors"
                >
                  <X size={20} />
                </button>
              </div>

              <form className="space-y-6">
                <div>
                  <label className="block text-sm font-medium text-gray-900 mb-2">
                    Nazwa piwa
                  </label>
                  <input
                    type="text"
                    className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-amber-500 focus:border-amber-500 text-gray-900 placeholder-gray-500 bg-white"
                    placeholder="np. Tyskie Gronie"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-900 mb-2">
                    Cena (zł)
                  </label>
                  <input
                    type="number"
                    step="0.01"
                    className="w-full px-4 py-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-amber-500 focus:border-amber-500 text-gray-900 placeholder-gray-500 bg-white"
                    placeholder="0.00"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-900 mb-2">
                    Zdjęcie (opcjonalne)
                  </label>
                  <div 
                    className={`relative border-2 border-dashed rounded-xl p-4 text-center ${
                      isDragging ? 'border-amber-500 bg-amber-50' : 'border-gray-300 hover:border-gray-400'
                    }`}
                    onDragOver={handleDragOver}
                    onDragLeave={handleDragLeave}
                    onDrop={handleDrop}
                  >
                    {previewImage ? (
                      <div className="relative">
                        <img 
                          src={previewImage} 
                          alt="Preview" 
                          className="w-full h-48 object-cover rounded-lg"
                        />
                        <button
                          type="button"
                          onClick={() => setPreviewImage(null)}
                          className="absolute top-2 right-2 p-1 bg-white rounded-full shadow-md hover:bg-gray-100"
                        >
                          <X size={16} />
                        </button>
                      </div>
                    ) : (
                      <div className="flex flex-col items-center justify-center py-6">
                        <Camera className="w-12 h-12 text-gray-400 mb-2" />
                        <p className="text-sm text-gray-500 mb-2">Przeciągnij zdjęcie lub</p>
                        <label className="cursor-pointer">
                          <span className="bg-white px-4 py-2 rounded-lg text-sm text-amber-600 hover:text-amber-700 font-medium">
                            Wybierz plik
                          </span>
                          <input
                            type="file"
                            className="hidden"
                            accept="image/*"
                            onChange={handleImageChange}
                          />
                        </label>
                      </div>
                    )}
                  </div>
                </div>

                <button
                  type="submit"
                  className="w-full bg-gradient-to-r from-amber-500 to-amber-600 text-white py-3 px-4 rounded-xl hover:from-amber-600 hover:to-amber-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-amber-500 shadow-md hover:shadow-lg transition-all font-medium"
                >
                  Dodaj piwo
                </button>
              </form>
            </div>
          </Dialog.Panel>
        </div>
      </Dialog>
    </div>
  );
};

export default VenuePopupActions;

================
File: globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}

================
File: hooks/useAuth.ts
================
// src/app/hooks/useAuth.ts
import { create } from 'zustand';
import { getAuthToken, getUser, login as loginApi, logout as logoutApi } from '../services/auth';

interface AuthUser {
    id: number;
    email: string;
    name: string;
}

interface AuthState {
  token: string | null;
  user: AuthUser | null;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
}

export const useAuth = create<AuthState>((set) => ({
  token: getAuthToken(),
  user: getUser(),
  isAuthenticated: !!getAuthToken(),
  login: async (email: string, password: string) => {
    try {
      const response = await loginApi(email, password);
      set({
        token: response.token,
        user: response.user,
        isAuthenticated: true
      });
    } catch (error) {
      throw error;
    }
  },
  logout: () => {
    logoutApi();
    set({
      token: null,
      user: null,
      isAuthenticated: false
    });
  }
}));

================
File: hooks/useGeolocation.ts
================
import { useState, useEffect } from 'react';

interface GeolocationState {
  latitude: number;
  longitude: number;
  error: string | null;
  isLoading: boolean;
  isDefault: boolean;
  source: 'gps' | 'ip' | 'default';
  debug?: string;
}

const DEFAULT_LOCATION = {
  latitude: 52.2297,
  longitude: 21.0122
};

const getStoredLocation = () => {
  if (typeof window === 'undefined') return null;
  const stored = localStorage.getItem('lastKnownLocation');
  if (!stored) return null;
  try {
    const parsed = JSON.parse(stored);
    if (parsed.latitude && parsed.longitude) {
      return parsed;
    }
    return null;
  } catch {
    return null;
  }
};

export const useGeolocation = () => {
  const storedLocation = getStoredLocation();
  const [state, setState] = useState<GeolocationState>({
    ...(storedLocation || DEFAULT_LOCATION),
    error: null,
    isLoading: !storedLocation,
    isDefault: !storedLocation,
    source: storedLocation ? 'gps' : 'default'
  });

  useEffect(() => {
    let mounted = true;

    const getIpBasedLocation = async () => {
      try {
        const response = await fetch('https://ipwho.is/');
        if (!response.ok) throw new Error('IP API error');
        const data = await response.json();
        
        if (!data.success) throw new Error('IP data not available');

        return {
          latitude: data.latitude,
          longitude: data.longitude
        };
      } catch (error: unknown) {
        console.error('IP location error:', error);
        try {
          const backupResponse = await fetch('https://ip-api.com/json/?fields=lat,lon,status');
          const backupData = await backupResponse.json();
          
          if (backupData.status === 'success') {
            return {
              latitude: backupData.lat,
              longitude: backupData.lon
            };
          }
        } catch (backupError) {
          console.error('Backup IP location error:', backupError);
        }
        return null;
      }
    };

    const getGPSLocation = () => {
      return new Promise<GeolocationPosition>((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error('Geolokalizacja nie jest wspierana'));
          return;
        }

        if (navigator.permissions) {
          navigator.permissions.query({ name: 'geolocation' }).then((permissionStatus) => {
            if (permissionStatus.state === 'denied') {
              reject(new Error('Dostęp do lokalizacji jest zablokowany w przeglądarce'));
              return;
            }
          });
        }

        navigator.geolocation.getCurrentPosition(
          resolve,
          reject,
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 300000
          }
        );
      });
    };

    // Nasłuchuj zmian w localStorage
    const handleStorageChange = () => {
      const newLocation = getStoredLocation();
      if (newLocation) {
        setState(prev => ({
          ...prev,
          latitude: newLocation.latitude,
          longitude: newLocation.longitude,
          isDefault: false,
          source: 'gps',
          error: null
        }));
      }
    };

    window.addEventListener('storage', handleStorageChange);

    // Sprawdzaj localStorage w interwałach
    const checkStorage = setInterval(() => {
      const newLocation = getStoredLocation();
      if (newLocation && 
          (newLocation.latitude !== state.latitude || 
           newLocation.longitude !== state.longitude)) {
        if (mounted) {
          setState(prev => ({
            ...prev,
            latitude: newLocation.latitude,
            longitude: newLocation.longitude,
            isDefault: false,
            source: 'gps',
            error: null
          }));
        }
      }
    }, 1000);

    const initLocation = async () => {
      if (!mounted) return;
      
      // Jeśli mamy zapisaną lokalizację, użyj jej
      const storedLoc = getStoredLocation();
      if (storedLoc) {
        setState({
          latitude: storedLoc.latitude,
          longitude: storedLoc.longitude,
          error: null,
          isLoading: false,
          isDefault: false,
          source: 'gps'
        });
        return;
      }

      try {
        const gpsPosition = await getGPSLocation();
        
        if (mounted) {
          const newLocation = {
            latitude: gpsPosition.coords.latitude,
            longitude: gpsPosition.coords.longitude,
          };
          
          localStorage.setItem('lastKnownLocation', JSON.stringify(newLocation));
          
          setState({
            ...newLocation,
            error: null,
            isLoading: false,
            isDefault: false,
            source: 'gps'
          });
        }
      } catch (gpsError) {
        console.error('GPS error:', gpsError);
        try {
          const ipLocation = await getIpBasedLocation();
          
          if (mounted && ipLocation) {
            localStorage.setItem('lastKnownLocation', JSON.stringify(ipLocation));
            
            setState({
              ...ipLocation,
              error: gpsError instanceof Error ? gpsError.message : 'GPS niedostępny',
              isLoading: false,
              isDefault: false,
              source: 'ip'
            });
          }
        } catch {
          if (mounted) {
            setState(prev => ({
              ...prev,
              error: 'Nie udało się ustalić lokalizacji GPS ani IP',
              isLoading: false
            }));
          }
        }
      }
    };

    initLocation();

    return () => {
      mounted = false;
      window.removeEventListener('storage', handleStorageChange);
      clearInterval(checkStorage);
    };
  }, [state.latitude, state.longitude]);

  return state;
};

================
File: hooks/useNearbyVenues.ts
================
import { useState, useEffect, useCallback } from 'react';
import { Venue } from '../types';
import { fetchNearbyVenues } from '../services/api';

interface UseNearbyVenuesResult {
  venues: Venue[];
  isLoading: boolean;
  error: string | null;
  searchVenues: (term: string) => void;
}

export const useNearbyVenues = (
  latitude: number,
  longitude: number
): UseNearbyVenuesResult => {
  const [venues, setVenues] = useState<Venue[]>([]);
  const [filteredVenues, setFilteredVenues] = useState<Venue[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Funkcja do pobierania lokali
  const fetchVenues = useCallback(async () => {
    if (!latitude || !longitude) return;

    setIsLoading(true);
    setError(null);

    try {
      const result = await fetchNearbyVenues({
        latitude,
        longitude,
        radius: 15 // Stały większy promień, np. 100km
      });

      if (!result?.data) {
        throw new Error('Brak danych z API');
      }

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const venuesData = result.data.map((venue: any): Venue => ({
        id: venue.id,
        name: venue.name,
        beer: venue.cheapest_beer || 'Nieznane',
        price: venue.price ? `${Number(venue.price).toFixed(2)} zł` : 'Brak ceny',
        rating: venue.average_rating || 0,
        reviewCount: venue.review_count || 0,
        lat: venue.latitude,
        lng: venue.longitude,
        address: venue.address,
        distance: venue.distance
      }));

      // Sortuj po odległości z prawidłowymi typami
      const sortedVenues = venuesData.sort((a: Venue, b: Venue) => a.distance - b.distance);
      
      setVenues(sortedVenues);
      setFilteredVenues(sortedVenues);
    } catch (err) {
      console.error('Error loading venues:', err);
      setError(err instanceof Error ? err.message : 'Wystąpił błąd podczas ładowania lokali');
    } finally {
      setIsLoading(false);
    }
  }, [latitude, longitude]);

  // Pobierz lokale przy zmianie lokalizacji
  useEffect(() => {
    fetchVenues();
  }, [fetchVenues]);

  // Funkcja do wyszukiwania
  const searchVenues = useCallback((searchTerm: string) => {
    if (!searchTerm.trim()) {
      setFilteredVenues(venues);
      return;
    }

    const searchLower = searchTerm.toLowerCase();
    const filtered = venues.filter(venue => 
      venue.name.toLowerCase().includes(searchLower) ||
      venue.address?.toLowerCase().includes(searchLower) ||
      venue.beer.toLowerCase().includes(searchLower) ||
      venue.price.toLowerCase().includes(searchLower)
    );

    setFilteredVenues(filtered);
  }, [venues]);

  return {
    venues: filteredVenues,
    isLoading,
    error,
    searchVenues
  };
};

================
File: hooks/useVenues.ts
================
import { useState, useEffect, useCallback, useRef } from 'react';
import { Venue } from '../types';
import { fetchNearbyVenues } from '../services/api';

interface VenueApiResponse {
  id: number;
  name: string;
  address: string;
  latitude: number;
  longitude: number;
  description: string;
  open: 'open' | 'closed' | 'unknown';
  status: string;
  verified: boolean;
  average_rating: number;
  review_count: number;
  cheapest_beer: string | null;
  price: number | null;
  distance: number;
}

interface GridCell {
  lat: number;
  lng: number;
  zoom: number;
}

interface MapBounds {
  north: number;
  south: number;
  east: number;
  west: number;
}

interface CacheEntry {
  timestamp: number;
  venues: Venue[];
  bounds: MapBounds;
}

interface MapCenter {
  latitude: number;
  longitude: number;
  zoom: number;
}

// Stałe konfiguracyjne
const CACHE_LIFETIME = 5 * 60 * 1000; // 5 minut
const GRID_SIZE = 0.1; // Wielkość komórki siatki w stopniach
const MIN_ZOOM_CHANGE = 2; // Minimalna zmiana zoomu wymuszająca odświeżenie
const DEBOUNCE_DELAY = 300; // Opóźnienie debounce w ms
const MAX_VENUES_LIST = 40; // Maksymalna liczba lokali na liście

export const useVenues = (initialLat: number, initialLng: number) => {
  const [venues, setVenues] = useState<Venue[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [mapCenter, setMapCenter] = useState<MapCenter>({
    latitude: initialLat,
    longitude: initialLng,
    zoom: 13
  });

  const cachedAreas = useRef<Map<string, CacheEntry>>(new Map());
  const loadingRef = useRef<boolean>(false);
  const lastFetch = useRef<GridCell | null>(null);
  const debounceTimeout = useRef<NodeJS.Timeout | undefined>(undefined);

  // Zaokrąglanie do siatki
  const roundToGrid = (value: number): number => {
    return Math.round(value / GRID_SIZE) * GRID_SIZE;
  };

  // Generowanie klucza cache
  const generateCacheKey = (cell: GridCell): string => {
    return `${cell.lat.toFixed(3)},${cell.lng.toFixed(3)},${cell.zoom}`;
  };

  // Sprawdzanie czy należy pobrać nowe dane
  const shouldFetchNewData = (newCell: GridCell): boolean => {
    if (!lastFetch.current) return true;

    const zoomChanged = Math.abs(lastFetch.current.zoom - newCell.zoom) >= MIN_ZOOM_CHANGE;
    const positionChanged = 
      Math.abs(lastFetch.current.lat - newCell.lat) >= GRID_SIZE ||
      Math.abs(lastFetch.current.lng - newCell.lng) >= GRID_SIZE;

    return zoomChanged || positionChanged;
  };

  // Czyszczenie starego cache
  const clearOldCache = useCallback(() => {
    const now = Date.now();
    const expiredKeys: string[] = [];

    cachedAreas.current.forEach((entry, key) => {
      if (now - entry.timestamp > CACHE_LIFETIME) {
        expiredKeys.push(key);
      }
    });

    expiredKeys.forEach(key => cachedAreas.current.delete(key));
  }, []);

  // Główna funkcja pobierająca dane
  const loadVenuesForLocation = useCallback(async (center: MapCenter) => {
    if (loadingRef.current) return;

    const cell: GridCell = {
      lat: roundToGrid(center.latitude),
      lng: roundToGrid(center.longitude),
      zoom: Math.round(center.zoom)
    };

    // Sprawdź czy potrzebujemy nowych danych
    if (!shouldFetchNewData(cell)) return;

    const cacheKey = generateCacheKey(cell);
    clearOldCache();

    // Sprawdź cache
    const cachedEntry = cachedAreas.current.get(cacheKey);
    if (cachedEntry && Date.now() - cachedEntry.timestamp < CACHE_LIFETIME) {
      setVenues(cachedEntry.venues);
      setIsLoading(false);
      return;
    }

    loadingRef.current = true;
    setIsLoading(true);

    try {
      const result = await fetchNearbyVenues({
        latitude: center.latitude,
        longitude: center.longitude,
        zoom: center.zoom
      });

      if (!result?.data) {
        throw new Error('Brak danych z API');
      }

      const newVenues = result.data.map((venue: VenueApiResponse): Venue => ({
        id: venue.id,
        name: venue.name,
        beer: venue.cheapest_beer || 'Nieznane',
        price: venue.price ? `${Number(venue.price).toFixed(2)} zł` : 'Brak ceny',
        rating: venue.average_rating || 0,
        reviewCount: venue.review_count || 0,
        lat: venue.latitude,
        lng: venue.longitude,
        address: venue.address,
        distance: venue.distance
      }));

      // Zapisz w cache
      cachedAreas.current.set(cacheKey, {
        timestamp: Date.now(),
        venues: newVenues,
        bounds: {
          north: center.latitude + GRID_SIZE,
          south: center.latitude - GRID_SIZE,
          east: center.longitude + GRID_SIZE,
          west: center.longitude - GRID_SIZE
        }
      });

      lastFetch.current = cell;
      setVenues(newVenues);
      setError(null);
    } catch (err) {
      console.error('Error loading venues:', err);
      setError(err instanceof Error ? err.message : 'Wystąpił błąd podczas ładowania lokali');
      setVenues([]);
    } finally {
      setIsLoading(false);
      loadingRef.current = false;
    }
  }, [clearOldCache]);

  // Załaduj początkowe dane
  useEffect(() => {
    loadVenuesForLocation({
      latitude: initialLat,
      longitude: initialLng,
      zoom: 13
    });
  }, [initialLat, initialLng, loadVenuesForLocation]);

  // Obsługa zmiany centrum mapy z debounce
  const handleMapChange = useCallback((newCenter: MapCenter) => {
    if (debounceTimeout.current) {
      clearTimeout(debounceTimeout.current);
    }

    debounceTimeout.current = setTimeout(() => {
      setMapCenter(newCenter);
      loadVenuesForLocation(newCenter);
    }, DEBOUNCE_DELAY);
  }, [loadVenuesForLocation]);

  // Czyszczenie timeoutów
  useEffect(() => {
    return () => {
      if (debounceTimeout.current) {
        clearTimeout(debounceTimeout.current);
      }
    };
  }, []);

  // Filtrowanie lokali
  const filteredVenues = venues.filter(venue => {
    if (!searchTerm) return true;
    
    const searchLower = searchTerm.toLowerCase();
    return (
      venue.name.toLowerCase().includes(searchLower) ||
      venue.address?.toLowerCase().includes(searchLower) ||
      venue.beer.toLowerCase().includes(searchLower) ||
      venue.price.toLowerCase().includes(searchLower)
    );
  });

  // Pobieranie lokali do widoku listy
  const getListVenues = useCallback(() => {
    return [...filteredVenues]
      .sort((a, b) => a.distance - b.distance)
      .slice(0, MAX_VENUES_LIST);
  }, [filteredVenues]);

  return {
    venues: filteredVenues,
    listVenues: getListVenues(),
    isLoading,
    error,
    setSearchTerm,
    handleMapChange,
    mapCenter
  };
};

export default useVenues;

================
File: layout.tsx
================
import { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import ClientLayout from "./ClientLayout";
import AppLayout from './components/layout/AppLayout';

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "BeerSpots - Znajdź najtańsze piwo w okolicy",
  description: "Aplikacja pokazująca ceny piwa w lokalach w twojej okolicy",
  icons: {
    icon: "/favicon.ico",
  },
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="pl">
      <head>
        <meta charSet="utf-8" />
        <meta 
          name="viewport" 
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
        />
        <meta 
          httpEquiv="Content-Security-Policy" 
          content="default-src * 'self' 'unsafe-inline' 'unsafe-eval' data: gap: content: https://ssl.gstatic.com 'unsafe-eval'; style-src * 'self' 'unsafe-inline'; media-src *; img-src * 'self' data: content:;"
        />
        <link
          rel="stylesheet"
          href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossOrigin=""
        />
        <link
          rel="stylesheet"
          href="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol@0.79.0/dist/L.Control.Locate.min.css"
        />
        <link 
          rel="stylesheet" 
          href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" 
        />
        <link 
          rel="stylesheet" 
          href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" 
        />
      </head>
      <body className={`${inter.className} antialiased min-h-screen bg-gray-50`}>
        <ClientLayout>
          <AppLayout>{children}</AppLayout>
        </ClientLayout>
      </body>
    </html>
  );
}

================
File: page.tsx
================
'use client';

import { useState, useEffect } from 'react';
import { BeerMap } from './components/map/BeerMap';
import { VenueList } from './components/venues/VenueList';
import { useVenues } from './hooks/useVenues';
import { useNearbyVenues } from './hooks/useNearbyVenues';
import { useGeolocation } from './hooks/useGeolocation';
import { AuthModal } from './components/auth/AuthModal';
import { useAuth } from './hooks/useAuth';
import FavoritesList from './components/favorites/FavoritesList';
import { useFavoritesStore } from './stores/useFavoritesStore';
import { toast } from 'react-hot-toast';
import { Map, ListOrdered, Heart, Plus, UserCircle, LogOut, Search } from 'lucide-react';
import { addBeerSpot, addBeerToBeerSpot } from './services/api';
import type { Map as LeafletMap } from 'leaflet';
import NewVenueForm from './components/forms/NewVenueForm';

// Bottom Navigation Component
const BottomNavigation = ({
  activeTab,
  onTabChange,
  isAuthenticated
}: {
  activeTab: string;
  onTabChange: (tab: string) => void;
  isAuthenticated: boolean;
}) => {
  const navItems = [
    { id: 'map', label: 'Mapa', icon: <Map size={20} /> },
    { id: 'list', label: 'Lista', icon: <ListOrdered size={20} /> },
    { id: 'add', label: 'Dodaj', icon: <Plus size={20} /> },
    ...(isAuthenticated ? [{ id: 'favorites', label: 'Ulubione', icon: <Heart size={20} /> }] : [])
  ];

  return (
    <div className="fixed bottom-0 left-0 right-0 bg-white border-t shadow-lg z-40">
      <div className="max-w-lg mx-auto px-4">
        <div className="flex justify-around items-center h-16">
          {navItems.map((item) => (
            <button
              key={item.id}
              onClick={() => onTabChange(item.id)}
              className={`flex flex-col items-center justify-center px-3 py-2 rounded-lg transition-colors ${
                activeTab === item.id
                  ? 'text-amber-600'
                  : 'text-gray-600 hover:text-amber-600'
              }`}
            >
              {item.icon}
              <span className="text-xs mt-1">{item.label}</span>
            </button>
          ))}
        </div>
      </div>
    </div>
  );
};

// Profile Dropdown Component
const ProfileDropdown = ({ 
  isProfileOpen,
  user,
  handleLogout,
  openAuthModal
}: {
  isProfileOpen: boolean;
  user: { name: string; email: string; } | null;
  handleLogout: () => void;
  openAuthModal: (mode: 'login' | 'register') => void;
}) => {
  if (!isProfileOpen) return null;

  return (
    <div className="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg border py-1 z-50">
      {user ? (
        <>
          <div className="px-4 py-2 text-sm border-b">
            <div className="text-gray-900 font-medium">Witaj {user.name}!</div>
          </div>
          <button
            onClick={handleLogout}
            className="w-full flex items-center px-4 py-2 text-sm text-red-600 hover:bg-red-50"
          >
            <LogOut size={16} className="mr-2" />
            Wyloguj się
          </button>
        </>
      ) : (
        <>
          <button
            onClick={() => openAuthModal('login')}
            className="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-50"
          >
            Zaloguj się
          </button>
          <button
            onClick={() => openAuthModal('register')}
            className="w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-50"
          >
            Zarejestruj się
          </button>
        </>
      )}
    </div>
  );
};

export default function Home() {
  const [isClient, setIsClient] = useState(false);
  const [isProfileOpen, setIsProfileOpen] = useState(false);
  const [activeTab, setActiveTab] = useState('map');
  const [localSearchTerm, setLocalSearchTerm] = useState('');
  const [isAuthModalOpen, setAuthModalOpen] = useState(false);
  const [authModalMode, setAuthModalMode] = useState<'login' | 'register'>('login');
  const [selectedLocation, setSelectedLocation] = useState<{lat: number; lng: number} | null>(null);
  const [mapInstance, setMapInstance] = useState<LeafletMap | null>(null);

  const { latitude, longitude, error: geoError, source: geoSource } = useGeolocation();
  
  const { 
    venues: mapVenues, 
    setSearchTerm: setMapSearchTerm, 
    handleMapChange 
  } = useVenues(latitude, longitude);

  const {
    venues: listVenues,
    isLoading: isListLoading,
    error: listError,
    searchVenues
  } = useNearbyVenues(latitude, longitude);

  const { isAuthenticated, user, logout } = useAuth();

  useEffect(() => {
    setIsClient(true);
  }, []);

  useEffect(() => {
    if (isAuthenticated) {
      useFavoritesStore.getState().fetchFavorites();
    }
  }, [isAuthenticated]);

  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setLocalSearchTerm(value);
    setMapSearchTerm(value);
    searchVenues(value);
  };

  const handleLogout = () => {
    logout();
    setIsProfileOpen(false);
    setSelectedLocation(null);
    if (activeTab === 'favorites' || activeTab === 'add') {
      setActiveTab('map');
    }

    if (mapInstance) {
      mapInstance.closePopup();
    }
  };

  const handleTabChange = (tabId: string) => {
    if (mapInstance) {
      mapInstance.closePopup();
    }
  
    if (tabId === 'add') {
      if (!isAuthenticated) {
        openAuthModal('login');
        return;
      }
      setSelectedLocation(null);
      toast.success('Kliknij na mapie, aby wybrać lokalizację', {
        duration: 3000,
        icon: '📍',
        style: {
          border: '1px solid #34D399',
          padding: '12px',
          color: '#065F46',
        },
      });
    } else {
      setSelectedLocation(null);
    }
    
    setActiveTab(tabId);
  };

  const openAuthModal = (mode: 'login' | 'register') => {
    setAuthModalMode(mode);
    setAuthModalOpen(true);
    setIsProfileOpen(false);
  };

  const handleCloseAuthModal = () => {
    setAuthModalOpen(false);
    setAuthModalMode('login');
  };

  const handleMapReady = (map: LeafletMap) => {
    setMapInstance(map);
  };

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const handleVenueSubmit = async (formData: any) => {
    if (!selectedLocation) return;
    
    try {
      const spotId = await addBeerSpot({
        name: formData.name,
        address: formData.address,
        latitude: selectedLocation.lat,
        longitude: selectedLocation.lng,
        description: '',
        opening_hours: {
          monday: { open: '12:00', close: '23:00' },
          tuesday: { open: '12:00', close: '23:00' },
          wednesday: { open: '12:00', close: '23:00' },
          thursday: { open: '12:00', close: '23:00' },
          friday: { open: '12:00', close: '23:00' },
          saturday: { open: '12:00', close: '23:00' },
          sunday: { open: '12:00', close: '23:00' }
        }
      });
  
      await addBeerToBeerSpot(spotId, {
        name: formData.beerName,
        price: Number(formData.beerPrice),
        type: formData.beerType || 'lager',
        alcohol_percentage: Number(formData.alcoholPercentage || 0),
        status: 'available'
      });
  
      toast.success('Miejsce zostało dodane!');
      setSelectedLocation(null);
      setActiveTab('map');
      window.location.reload();
    } catch (error) {
      console.error('Error adding venue:', error);
      toast.error('Wystąpił błąd podczas dodawania miejsca');
    }
  };

  if (!isClient) return null;

  return (
    <div className="min-h-screen bg-gray-50">
      <AuthModal
        isOpen={isAuthModalOpen}
        onClose={handleCloseAuthModal}
        initialMode={authModalMode}
      />

      {isClient && (
        <header className="fixed top-0 right-0 left-0 bg-white border-b z-40">
          <div className="flex items-center justify-between h-12 px-4">
            <div className="flex items-center space-x-3">
              <span className="text-2xl">🍺</span>
              <h1 className="text-xl font-bold text-amber-600 hidden sm:block">BeerSpots</h1>
            </div>
            
            <div className="flex-1 max-w-2xl mx-auto px-4">
              <div className="relative">
                <input
                  type="text"
                  value={localSearchTerm}
                  onChange={handleSearchChange}
                  placeholder="Szukaj lokalu, piwa lub adresu..."
                  className="w-full pl-10 pr-4 py-1.5 rounded-lg border-2 border-gray-200 focus:border-amber-500 focus:ring-2 focus:ring-amber-200"
                />
                <Search className="absolute left-3 top-2 w-5 h-5 text-gray-400" />
              </div>
            </div>

            <div className="relative ml-4">
              <button
                onClick={() => setIsProfileOpen(!isProfileOpen)}
                className="p-1.5 rounded-lg hover:bg-gray-100 transition-colors"
              >
                <UserCircle className="w-6 h-6 text-gray-600" />
              </button>

              <ProfileDropdown 
                isProfileOpen={isProfileOpen}
                user={user}
                handleLogout={handleLogout}
                openAuthModal={openAuthModal}
              />
            </div>
          </div>
        </header>
      )}

      <main className="relative h-[calc(100vh-4rem)]">
        <div className="h-full">
          <BeerMap
            venues={mapVenues}
            onMapClick={(e) => {
              if (activeTab === 'add') {
                setSelectedLocation({
                  lat: e.latlng.lat,
                  lng: e.latlng.lng
                });
              } else {
                setSelectedLocation(null);
              }
            }}
            isAddMode={activeTab === 'add'}
            selectedLocation={selectedLocation}
            onBoundsChanged={handleMapChange}
            onMapReady={handleMapReady}
          />
        </div>
        
        {activeTab === 'list' && (
          <div className="absolute top-0 left-0 right-0 bottom-0 bg-white overflow-y-auto pb-0 z-[30]"> 
            <div className="p-4 min-h-full bg-white">
              <VenueList
                venues={listVenues}
                isLoading={isListLoading}
                error={listError || (geoError && geoSource === 'default' ? 'Nie można załadować lokali - problem z lokalizacją' : null)}
              />
            </div>
          </div>
        )}

        {activeTab === 'favorites' && isAuthenticated && (
          <div className="absolute top-0 left-0 right-0 bottom-0 bg-white overflow-y-auto pb-0 z-[30]">
            <div className="p-4 min-h-full bg-white">
              <FavoritesList />
            </div>
          </div>
        )}

        {activeTab === 'add' && selectedLocation && (
          <div className="fixed inset-x-0 bottom-16 bg-white border-t rounded-t-xl shadow-lg z-50 max-h-[80vh] overflow-y-auto">
            <div className="p-6">
              <NewVenueForm
                selectedLocation={selectedLocation}
                onSubmit={handleVenueSubmit}
                onCancel={() => {
                  setSelectedLocation(null);
                  setActiveTab('map');
                }}
              />
            </div>
          </div>
        )}  
      </main>

      <BottomNavigation
        activeTab={activeTab}
        onTabChange={handleTabChange}
        isAuthenticated={isAuthenticated}
      />
    </div>
  );
}

================
File: services/api.ts
================
import { getAuthToken } from './auth';

const API_URL = 'https://piwo.jacolos.pl/api';

// Interfaces
interface MapBounds {
  north: number;
  south: number;
  east: number;
  west: number;
}

interface FetchVenuesOptions {
  latitude: number;
  longitude: number;
  radius?: number;
  bounds?: MapBounds;
  zoom?: number;
}

interface ReviewData {
  rating: number;
  comment: string;
  visit_date: string;
}

interface CreateBeerSpotData {
  name: string;
  address: string;
  description: string;
  latitude: number;
  longitude: number;
  opening_hours: {
    [key: string]: {
      open: string;
      close: string;
    };
  };
}

interface AddBeerData {
  name: string;
  price: number;
  type: string;
  alcohol_percentage: number;
  status: string;
}

interface BeerData {
  price: number;
  type: string;
  alcohol_percentage: number;
  status: string;
  name: string;
}

// Helper Functions
const getHeaders = () => {
  const token = getAuthToken();
  return {
    'Content-Type': 'application/json',
    ...(token ? { 'Authorization': `Bearer ${token}` } : {})
  };
};

const calculateRadius = (zoom: number): number => {
  if (zoom >= 15) return 5;    // bardzo blisko
  if (zoom >= 13) return 10;   // miasto
  if (zoom >= 11) return 25;   // region
  if (zoom >= 9) return 50;    // województwo
  return 100;                  // cały kraj
};

const handleApiError = async (response: Response) => {
  if (!response.ok) {
    let errorMessage = 'Wystąpił błąd podczas komunikacji z serwerem';
    try {
      const errorData = await response.json();
      errorMessage = errorData.message || errorMessage;
    } catch {
      // Jeśli nie możemy sparsować JSON, używamy domyślnej wiadomości
    }
    throw new Error(errorMessage);
  }
  return response;
};

// Beer Spots API Functions
export const fetchNearbyVenues = async (options: FetchVenuesOptions) => {
  try {
    const radius = options.radius || calculateRadius(options.zoom || 13);
    
    const params = new URLSearchParams({
      latitude: options.latitude.toString(),
      longitude: options.longitude.toString(),
      radius: radius.toString()
    });
    
    const response = await fetch(`${API_URL}/beer-spots/nearbywithbeers?${params}`, {
      headers: getHeaders()
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error in fetchNearbyVenues:', error);
    throw error;
  }
};

export const fetchBeerSpot = async (id: number) => {
  try {
    const response = await fetch(`${API_URL}/beer-spots/${id}`, {
      headers: getHeaders()
    }).then(handleApiError);
    
    return response.json();
  } catch (error) {
    console.error('Error fetching beer spot:', error);
    throw error;
  }
};

export const addBeerSpot = async (data: CreateBeerSpotData): Promise<number> => {
  const token = getAuthToken();
  if (!token) {
    throw new Error('Musisz być zalogowany, aby dodać lokal');
  }

  try {
    const response = await fetch(`${API_URL}/beer-spots`, {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify(data)
    }).then(handleApiError);

    const responseData = await response.json();
    return responseData.data.id;
  } catch (error) {
    console.error('Error adding beer spot:', error);
    throw error;
  }
};

export const updateBeerSpot = async (id: number, data: Partial<CreateBeerSpotData>) => {
  try {
    const response = await fetch(`${API_URL}/beer-spots/${id}`, {
      method: 'PUT',
      headers: getHeaders(),
      body: JSON.stringify(data)
    }).then(handleApiError);

    return response.json();
  } catch (error) {
    console.error('Error updating beer spot:', error);
    throw error;
  }
};

export const deleteBeerSpot = async (id: number) => {
  try {
    await fetch(`${API_URL}/beer-spots/${id}`, {
      method: 'DELETE',
      headers: getHeaders()
    }).then(handleApiError);
  } catch (error) {
    console.error('Error deleting beer spot:', error);
    throw error;
  }
};

// Beers API Functions
export const fetchBeers = async (spotId: number) => {
  try {
    const response = await fetch(`${API_URL}/beer-spots/${spotId}/beers`, {
      headers: getHeaders()
    }).then(handleApiError);

    return response.json();
  } catch (error) {
    console.error('Error fetching beers:', error);
    throw error;
  }
};

export const addBeerToBeerSpot = async (spotId: number, data: AddBeerData) => {
  const token = getAuthToken();
  if (!token) {
    throw new Error('Musisz być zalogowany, aby dodać piwo');
  }

  const response = await fetch(`${API_URL}/beer-spots/${spotId}/beers`, {
    method: 'POST',
    headers: getHeaders(),
    body: JSON.stringify(data)
  });

  if (!response.ok) throw new Error('Nie udało się dodać piwa');
  return response.json();
};

export const updateBeer = async (beerId: number, data: Partial<BeerData>) => {
  try {
    const response = await fetch(`${API_URL}/beers/${beerId}`, {
      method: 'PUT',
      headers: getHeaders(),
      body: JSON.stringify(data)
    }).then(handleApiError);

    return response.json();
  } catch (error) {
    console.error('Error updating beer:', error);
    throw error;
  }
};

export const deleteBeer = async (beerId: number) => {
  try {
    await fetch(`${API_URL}/beers/${beerId}`, {
      method: 'DELETE',
      headers: getHeaders()
    }).then(handleApiError);
  } catch (error) {
    console.error('Error deleting beer:', error);
    throw error;
  }
};

// Reviews API Functions
export const fetchReviews = async (spotId: number) => {
  try {
    const response = await fetch(`${API_URL}/beer-spots/${spotId}/reviews`, {
      headers: getHeaders()
    }).then(handleApiError);

    return response.json();
  } catch (error) {
    console.error('Error fetching reviews:', error);
    throw error;
  }
};

export const fetchSpotReviews = async (spotId: number) => {
  try {
    const response = await fetch(`${API_URL}/beer-spots/${spotId}/spot-reviews`, {
      headers: getHeaders()
    }).then(handleApiError);

    return response.json();
  } catch (error) {
    console.error('Error fetching spot reviews:', error);
    throw error;
  }
};

export const addReview = async (spotId: number, data: ReviewData) => {
  try {
    const response = await fetch(`${API_URL}/beer-spots/${spotId}/reviews`, {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify(data)
    }).then(handleApiError);

    return response.json();
  } catch (error) {
    console.error('Error adding review:', error);
    throw error;
  }
};

export const updateReview = async (reviewId: number, data: Partial<ReviewData>) => {
  try {
    const response = await fetch(`${API_URL}/reviews/${reviewId}`, {
      method: 'PUT',
      headers: getHeaders(),
      body: JSON.stringify(data)
    }).then(handleApiError);

    return response.json();
  } catch (error) {
    console.error('Error updating review:', error);
    throw error;
  }
};

export const deleteReview = async (reviewId: number) => {
  try {
    await fetch(`${API_URL}/reviews/${reviewId}`, {
      method: 'DELETE',
      headers: getHeaders()
    }).then(handleApiError);
  } catch (error) {
    console.error('Error deleting review:', error);
    throw error;
  }
};

// Profile API Functions
export const fetchProfile = async () => {
  try {
    const response = await fetch(`${API_URL}/profile`, {
      headers: getHeaders()
    }).then(handleApiError);

    return response.json();
  } catch (error) {
    console.error('Error fetching profile:', error);
    throw error;
  }
};

export const checkAuth = async () => {
  const token = getAuthToken();
  if (!token) return false;

  try {
    await fetchProfile();
    return true;
  } catch {
    return false;
  }
};

================
File: services/auth.ts
================
import { create } from 'zustand';

interface LoginResponse {
  token: string;
  user: {
    id: number;
    email: string;
    name: string;
  };
}

interface RegisterData {
  name: string;
  email: string;
  password: string;
  password_confirmation: string;
}

interface AuthUser {
  id: number;
  email: string;
  name: string;
}

interface AuthState {
  token: string | null;
  user: AuthUser | null;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
}

const isClient = typeof window !== 'undefined';

export const register = async (data: RegisterData): Promise<LoginResponse> => {
  try {
    const response = await fetch('https://piwo.jacolos.pl/api/auth/register', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    });

    const responseData = await response.json();

    if (!response.ok) {
      if (response.status === 422) {
        // Błędy walidacji
        const errorMessages = Object.values(responseData.errors).flat();
        throw new Error(errorMessages[0] as string);
      }
      throw new Error(responseData.message || 'Błąd rejestracji');
    }

    if (isClient) {
      localStorage.setItem('authToken', responseData.token);
      localStorage.setItem('user', JSON.stringify(responseData.user));
    }
    return responseData;
  } catch (error) {
    console.error('Registration error:', error);
    throw error;
  }
};

export const login = async (email: string, password: string): Promise<LoginResponse> => {
  try {
    const response = await fetch('https://piwo.jacolos.pl/api/auth/login', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ email, password })
    });

    const data = await response.json();

    if (!response.ok) {
      if (response.status === 422) {
        // Błędy walidacji
        const errorMessages = Object.values(data.errors).flat();
        throw new Error(errorMessages[0] as string);
      }
      throw new Error(data.message || 'Nieprawidłowy email lub hasło');
    }

    if (isClient) {
      localStorage.setItem('authToken', data.token);
      localStorage.setItem('user', JSON.stringify(data.user));
    }
    return data;
  } catch (error) {
    console.error('Login error:', error);
    throw error;
  }
};

export const logout = async () => {
  try {
    const token = getAuthToken();
    if (token) {
      const response = await fetch('https://piwo.jacolos.pl/api/auth/logout', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        }
      });

      if (!response.ok) {
        throw new Error('Błąd podczas wylogowywania');
      }
    }
  } catch (error) {
    console.error('Logout error:', error);
  } finally {
    if (isClient) {
      localStorage.removeItem('authToken');
      localStorage.removeItem('user');
    }
  }
};

export const getAuthToken = (): string | null => {
  if (!isClient) return null;
  return localStorage.getItem('authToken');
};

export const getUser = (): AuthUser | null => {
  if (!isClient) return null;
  const userStr = localStorage.getItem('user');
  return userStr ? JSON.parse(userStr) : null;
};

export const useAuth = create<AuthState>((set) => ({
  token: getAuthToken(),
  user: getUser(),
  isAuthenticated: !!getAuthToken(),
  login: async (email: string, password: string) => {
    try {
      const response = await login(email, password);
      set({
        token: response.token,
        user: response.user,
        isAuthenticated: true
      });
    } catch (error) {
      throw error;
    }
  },
  logout: async () => {
    await logout();
    set({
      token: null,
      user: null,
      isAuthenticated: false
    });
  }
}));

================
File: stores/useFavoritesStore.ts
================
import { create } from 'zustand';
import { toast } from 'react-hot-toast';

interface Beer {
  name: string;
  price: number;
  type?: string;
  alcohol_percentage?: number;
  status?: string;
}

interface FavoriteSpot {
  id: number;
  name: string;
  address: string;
  latitude: number;
  longitude: number;
  average_rating: number;
  beers: Beer[];
  reviews_count?: number;
}

interface FavoritesMeta {
  total: number;
  max_allowed: number;
  remaining_slots: number;
}

interface FavoritesState {
  favorites: FavoriteSpot[];
  isLoading: boolean;
  error: string | null;
  isInitialized: boolean;
  lastFetch: number | null;
  meta: FavoritesMeta;
  fetchFavorites: (force?: boolean) => Promise<void>;
  removeFavorite: (spotId: number) => Promise<void>;
  addFavorite: (spot: FavoriteSpot) => Promise<void>;
  toggleFavorite: (spotId: number, spotData: FavoriteSpot) => Promise<boolean>;
  isFavorite: (spotId: number) => boolean;
  canAddMore: () => boolean;
}

export const useFavoritesStore = create<FavoritesState>((set, get) => ({
  favorites: [],
  isLoading: false,
  error: null,
  isInitialized: false,
  lastFetch: null,
  meta: {
    total: 0,
    max_allowed: 3,
    remaining_slots: 3
  },

  isFavorite: (spotId: number) => {
    return get().favorites.some(fav => fav.id === spotId);
  },

  canAddMore: () => {
    const { meta } = get();
    return meta.remaining_slots > 0;
  },

  fetchFavorites: async (force = false) => {
    const state = get();
    const now = Date.now();
    
    if (state.isLoading) return;
    if (!force && 
        state.lastFetch && 
        (now - state.lastFetch < 30000) && 
        state.isInitialized) {
      return;
    }

    const token = localStorage.getItem('authToken');
    if (!token) {
      set({ 
        error: 'Musisz być zalogowany', 
        isInitialized: true 
      });
      return;
    }

    set({ isLoading: true });

    try {
      const response = await fetch('https://piwo.jacolos.pl/api/favorites', {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (!response.ok) throw new Error('Nie udało się pobrać ulubionych miejsc');
      
      const data = await response.json();
      
      set({ 
        favorites: data.data || [], 
        meta: data.meta || {
          total: 0,
          max_allowed: 3,
          remaining_slots: 3
        },
        error: null, 
        isLoading: false,
        isInitialized: true,
        lastFetch: now
      });
    } catch (err) {
      console.error('Error in fetchFavorites:', err);
      set({ 
        error: err instanceof Error ? err.message : 'Wystąpił błąd', 
        isLoading: false,
        isInitialized: true
      });
    }
  },

  toggleFavorite: async (spotId: number, spotData: FavoriteSpot) => {
    const token = localStorage.getItem('authToken');
    if (!token) {
      toast.error('Musisz być zalogowany, aby dodać do ulubionych');
      return false;
    }

    const isFavorite = get().isFavorite(spotId);
    const { meta } = get();
    
    // Jeśli próbujemy dodać nowe miejsce, sprawdź limit
    if (!isFavorite && meta.remaining_slots <= 0) {
      toast.error(
        'Osiągnięto limit 3 ulubionych miejsc. Usuń jedno z miejsc aby dodać nowe.', 
        {
          duration: 4000,
          icon: '⚠️',
          style: {
            background: '#FEF2F2',
            color: '#991B1B',
            border: '1px solid #FCA5A5',
          },
        }
      );
      return false;
    }

    set({ isLoading: true });

    try {
      const response = await fetch(`https://piwo.jacolos.pl/api/favorites/${spotId}`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      const responseData = await response.json();

      if (!response.ok) {
        throw new Error(responseData.message || 'Wystąpił błąd podczas aktualizacji ulubionych');
      }

      // Aktualizuj stan po udanej operacji na serwerze
      if (isFavorite) {
        set(state => ({
          favorites: state.favorites.filter(f => f.id !== spotId),
          meta: {
            ...state.meta,
            total: state.meta.total - 1,
            remaining_slots: state.meta.remaining_slots + 1
          }
        }));
        toast.success('Usunięto z ulubionych');
      } else {
        const beersResponse = await fetch(`https://piwo.jacolos.pl/api/beer-spots/${spotId}/beers`, {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });
        
        if (beersResponse.ok) {
          const beersData = await beersResponse.json();
          spotData.beers = beersData.data || [];
        }

        set(state => ({
          favorites: [...state.favorites, spotData],
          meta: {
            ...state.meta,
            total: state.meta.total + 1,
            remaining_slots: state.meta.remaining_slots - 1
          }
        }));
        toast.success('Dodano do ulubionych');
      }

      set({ isLoading: false });
      return !isFavorite;
    } catch (error) {
      set({ isLoading: false });
      toast.error(error instanceof Error ? error.message : 'Wystąpił błąd');
      return false;
    }
  },

  removeFavorite: async (spotId: number) => {
    const token = localStorage.getItem('authToken');
    if (!token) return;

    const spotToRemove = get().favorites.find(f => f.id === spotId);
    if (!spotToRemove) return;

    set(state => ({
      favorites: state.favorites.filter(f => f.id !== spotId),
      meta: {
        ...state.meta,
        total: state.meta.total - 1,
        remaining_slots: state.meta.remaining_slots + 1
      }
    }));

    try {
      const response = await fetch(`https://piwo.jacolos.pl/api/favorites/${spotId}`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (!response.ok) {
        // Przywróć poprzedni stan w przypadku błędu
        set(state => ({
          favorites: [...state.favorites, spotToRemove],
          meta: {
            ...state.meta,
            total: state.meta.total + 1,
            remaining_slots: state.meta.remaining_slots - 1
          }
        }));
        throw new Error('Nie udało się usunąć z ulubionych');
      }

      toast.success('Usunięto z ulubionych');
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Wystąpił błąd podczas usuwania z ulubionych');
    }
  },

  addFavorite: async (spot: FavoriteSpot) => {
    const token = localStorage.getItem('authToken');
    if (!token) {
      toast.error('Musisz być zalogowany, aby dodać do ulubionych');
      return;
    }

    const { meta } = get();
    if (meta.remaining_slots <= 0) {
      toast.error('Osiągnięto limit ulubionych miejsc. Usuń niektóre miejsca, aby dodać nowe.');
      return;
    }

    try {
      // Pobierz piwa przed dodaniem
      const beersResponse = await fetch(`https://piwo.jacolos.pl/api/beer-spots/${spot.id}/beers`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (beersResponse.ok) {
        const beersData = await beersResponse.json();
        spot.beers = beersData.data || [];
      }

      // Dodaj do ulubionych
      const response = await fetch(`https://piwo.jacolos.pl/api/favorites/${spot.id}`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.message || 'Nie udało się dodać do ulubionych');
      }

      set(state => ({
        favorites: [...state.favorites, spot],
        meta: {
          ...state.meta,
          total: state.meta.total + 1,
          remaining_slots: state.meta.remaining_slots - 1
        }
      }));

      toast.success('Dodano do ulubionych');
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Wystąpił błąd podczas dodawania do ulubionych');
    }
  }
}));

================
File: types/index.ts
================
// src/app/types/index.ts
export interface Venue {
  id: number;
  name: string;
  beer: string;
  price: string;
  rating: number;
  reviewCount: number; 
  lat: number;
  lng: number;
  address?: string;
  distance: number;
}

export interface AddPlaceFormData {
  name: string;
  address: string;
  description: string;
  latitude: number | null;
  longitude: number | null;
  beerName: string;
  beerPrice: number | null;
  beerType: string;
  alcoholPercentage: number | null;
}

export interface CreateBeerSpotData {
  name: string;
  address: string;
  description: string;
  latitude: number;
  longitude: number;
  opening_hours: {
    [key: string]: {
      open: string;
      close: string;
    };
  };
}

export interface AddBeerData {
  name: string;
  price: number;
  type: string;
  alcohol_percentage: number;
  status: string;
}

export interface BeerData {
  price: number;
  type: string;
  alcohol_percentage: number;
  status: string;
  name: string;
}

================
File: utils/constants.ts
================
// src/app/utils/constants.ts
export const DEFAULT_OPENING_HOURS = {
  monday: { open: '12:00', close: '23:00' },
  tuesday: { open: '12:00', close: '23:00' },
  wednesday: { open: '12:00', close: '23:00' },
  thursday: { open: '12:00', close: '23:00' },
  friday: { open: '12:00', close: '23:00' },
  saturday: { open: '14:00', close: '24:00' },
  sunday: { open: '14:00', close: '22:00' }
};

export const BEER_TYPES = [
  { value: 'lager', label: 'Lager' },
  { value: 'pilsner', label: 'Pilsner' },
  { value: 'ale', label: 'Ale' },
  { value: 'ipa', label: 'IPA' },
  { value: 'stout', label: 'Stout' },
  { value: 'porter', label: 'Porter' },
  { value: 'wheat', label: 'Pszeniczne' },
  { value: 'other', label: 'Inne' }
];
